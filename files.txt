cliux
â”œâ”€â”€ assets/
â”‚   â”œâ”€â”€ boxed.gif
â”‚       [Could not read file: stream did not contain valid UTF-8]
â”‚   â”œâ”€â”€ divider.gif
â”‚       [Could not read file: stream did not contain valid UTF-8]
â”‚   â”œâ”€â”€ label.gif
â”‚       [Could not read file: stream did not contain valid UTF-8]
â”‚   â””â”€â”€ section.gif
â”‚       [Could not read file: stream did not contain valid UTF-8]
â”œâ”€â”€ examples/
â”‚   â”œâ”€â”€ boxed.rs
â”‚       --- FILE CONTENT START ---
â”‚       use cliux::Boxed;
â”‚       
â”‚       fn main() {
â”‚           Boxed::new("Cliux Boxed")
â”‚               .content("This code uses the cliux library to create a boxed section.")
â”‚               .width(61)
â”‚               .print();
â”‚       }
â”‚       --- FILE CONTENT END ---
â”‚   â”œâ”€â”€ divider.rs
â”‚       --- FILE CONTENT START ---
â”‚       use cliux::components::Divider;
â”‚       
â”‚       fn main() {
â”‚           Divider::new(20).print();
â”‚       }
â”‚       --- FILE CONTENT END ---
â”‚   â”œâ”€â”€ label.rs
â”‚       --- FILE CONTENT START ---
â”‚       use cliux::Label;
â”‚       
â”‚       fn main() {
â”‚           Label::new("INFO").style("info").print();
â”‚           Label::new("âœ“ Done").style("success").print();
â”‚           Label::new("ERROR").style("error").print();
â”‚       
â”‚           let inline = Label::new("DEBUG").color("cyan").bold(true).inline();
â”‚           println!("Inline label: {}", inline);
â”‚       }
â”‚       --- FILE CONTENT END ---
â”‚   â””â”€â”€ section.rs
â”‚       --- FILE CONTENT START ---
â”‚       use cliux::components::Section;
â”‚       
â”‚       fn main() {
â”‚           // Section using default style 'â”€'
â”‚           Section::new("Section #1")
â”‚               .content("This is the content of the section.")
â”‚               .print();
â”‚       
â”‚           // Section using custom style '-'
â”‚           Section::new("Section #2")
â”‚               .content("This is the content of the section.")
â”‚               .style('-')
â”‚               .wrap(true)
â”‚               .print();
â”‚       
â”‚           // Section with .wrap(true)
â”‚           Section::new("Section #3")
â”‚               .content(
â”‚                   "This is a long sentence that will be wrapped intelligently across multiple lines.",
â”‚               )
â”‚               .wrap(true)
â”‚               .print();
â”‚       }
â”‚       --- FILE CONTENT END ---
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ boxed.rs
â”‚   â”‚       --- FILE CONTENT START ---
â”‚   â”‚       use crate::layout::pad;
â”‚   â”‚       
â”‚   â”‚       /// A bordered container for displaying content with a title.
â”‚   â”‚       ///
â”‚   â”‚       /// `Boxed` allows you to present information within a visually distinct
â”‚   â”‚       /// box in the terminal, complete with a title and multi-line content.
â”‚   â”‚       ///
â”‚   â”‚       /// # Examples
â”‚   â”‚       ///
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::Boxed;
â”‚   â”‚       ///
â”‚   â”‚       /// Boxed::new("Important Notice")
â”‚   â”‚       ///     .content("This is a message inside a box.\nIt can span multiple lines.")
â”‚   â”‚       ///     .width(60)
â”‚   â”‚       ///     .print();
â”‚   â”‚       /// ```
â”‚   â”‚       pub struct Boxed {
â”‚   â”‚           title: String,
â”‚   â”‚           content: String,
â”‚   â”‚           width: usize,
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”‚       impl Boxed {
â”‚   â”‚           /// Creates a new `Boxed` instance with the given title.
â”‚   â”‚           ///
â”‚   â”‚           /// The default width is 50 characters, and the content is initially empty.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `title` - The title to display at the top of the box.
â”‚   â”‚           pub fn new(title: &str) -> Self {
â”‚   â”‚               Self {
â”‚   â”‚                   title: title.to_string(),
â”‚   â”‚                   content: String::new(),
â”‚   â”‚                   width: 50,
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the main content of the box.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Boxed` instance,
â”‚   â”‚           /// allowing for method chaining. Newline characters (`\n`) in the
â”‚   â”‚           /// content will create new lines within the box.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `text` - The string slice containing the content for the box.
â”‚   â”‚           pub fn content(mut self, text: &str) -> Self {
â”‚   â”‚               self.content = text.to_string();
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the total width of the box, including borders.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Boxed` instance,
â”‚   â”‚           /// allowing for method chaining. The content and title will be
â”‚   â”‚           /// padded to fit this width.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `width` - The desired total width of the box in characters.
â”‚   â”‚           pub fn width(mut self, width: usize) -> Self {
â”‚   â”‚               self.width = width;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Prints the `Boxed` content to the console.
â”‚   â”‚           ///
â”‚   â”‚           /// This method renders the box with its title, borders, and content
â”‚   â”‚           /// to standard output.
â”‚   â”‚           pub fn print(&self) {
â”‚   â”‚               println!("â•­{:â”€<1$}â•®", "", self.width);
â”‚   â”‚               println!("â”‚ {} â”‚", pad(&self.title, self.width - 2));
â”‚   â”‚               println!("â”œ{:â”€<1$}â”¤", "", self.width);
â”‚   â”‚               for line in self.content.lines() {
â”‚   â”‚                   println!("â”‚ {} â”‚", pad(line, self.width - 2));
â”‚   â”‚               }
â”‚   â”‚               println!("â•°{:â”€<1$}â•¯", "", self.width);
â”‚   â”‚           }
â”‚   â”‚       }
â”‚   â”‚       --- FILE CONTENT END ---
â”‚   â”‚   â”œâ”€â”€ divider.rs
â”‚   â”‚       --- FILE CONTENT START ---
â”‚   â”‚       /// A customizable horizontal line for separating sections of output.
â”‚   â”‚       ///
â”‚   â”‚       /// The `Divider` struct allows you to easily create horizontal rules
â”‚   â”‚       /// in your terminal output, useful for visually separating different
â”‚   â”‚       /// parts of information. You can customize its width and the character
â”‚   â”‚       /// used to draw it.
â”‚   â”‚       ///
â”‚   â”‚       /// # Examples
â”‚   â”‚       ///
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::Divider;
â”‚   â”‚       ///
â”‚   â”‚       /// // A default divider of 50 characters
â”‚   â”‚       /// Divider::new(50).print();
â”‚   â”‚       ///
â”‚   â”‚       /// // A divider using '=' characters
â”‚   â”‚       /// Divider::new(30).style('=').print();
â”‚   â”‚       /// ```
â”‚   â”‚       pub struct Divider {
â”‚   â”‚           width: usize,
â”‚   â”‚           style: char, // e.g. 'â”€', '=', '.', etc.
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”‚       impl Divider {
â”‚   â”‚           /// Creates a new `Divider` instance with the specified width.
â”‚   â”‚           ///
â”‚   â”‚           /// By default, the divider will use the 'â”€' character as its style.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `width` - The desired total width of the divider in characters.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// A new `Divider` instance.
â”‚   â”‚           pub fn new(width: usize) -> Self {
â”‚   â”‚               Self {
â”‚   â”‚                   width, style: 'â”€'
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the character used to draw the divider.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Divider` instance,
â”‚   â”‚           /// allowing for method chaining.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `style` - The character to use for the divider (e.g., `'='`, `'-'`, `'*'`).
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Divider` instance with the updated style.
â”‚   â”‚           pub fn style(mut self, style: char) -> Self {
â”‚   â”‚               self.style = style;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Prints the `Divider` to the console.
â”‚   â”‚           ///
â”‚   â”‚           /// This method outputs a line of the chosen `style` character, repeated
â”‚   â”‚           /// `width` times, to standard output.
â”‚   â”‚           pub fn print(&self) {
â”‚   â”‚               println!("{}", self.style.to_string().repeat(self.width));
â”‚   â”‚           }
â”‚   â”‚       }
â”‚   â”‚       --- FILE CONTENT END ---
â”‚   â”‚   â”œâ”€â”€ label.rs
â”‚   â”‚       --- FILE CONTENT START ---
â”‚   â”‚       use ansi_term::Colour;
â”‚   â”‚       
â”‚   â”‚       /// Parses a string representation of a color into an `ansi_term::Colour` enum variant.
â”‚   â”‚       ///
â”‚   â”‚       /// This internal helper function supports a predefined set of color names (case-insensitive)
â”‚   â”‚       /// and returns `None` if the name does not match any supported color.
â”‚   â”‚       ///
â”‚   â”‚       /// Supported colors include: "black", "red", "green", "yellow", "blue", "purple", "magenta", "cyan", "white".
â”‚   â”‚       /// "purple" and "magenta" are treated as synonyms.
â”‚   â”‚       ///
â”‚   â”‚       /// # Arguments
â”‚   â”‚       ///
â”‚   â”‚       /// * `name` - A string slice representing the color name.
â”‚   â”‚       ///
â”‚   â”‚       /// # Returns
â”‚   â”‚       ///
â”‚   â”‚       /// An `Option<Colour>` which is `Some(Colour)` if the name is recognized, otherwise `None`.
â”‚   â”‚       fn parse_colour(name: &str) -> Option<Colour> {
â”‚   â”‚           match name.to_lowercase().as_str() {
â”‚   â”‚               "black" => Some(Colour::Black),
â”‚   â”‚               "red" => Some(Colour::Red),
â”‚   â”‚               "green" => Some(Colour::Green),
â”‚   â”‚               "yellow" => Some(Colour::Yellow),
â”‚   â”‚               "blue" => Some(Colour::Blue),
â”‚   â”‚               "purple" | "magenta" => Some(Colour::Purple),
â”‚   â”‚               "cyan" => Some(Colour::Cyan),
â”‚   â”‚               "white" => Some(Colour::White),
â”‚   â”‚               _ => None,
â”‚   â”‚           }
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”‚       /// A customizable text label designed for terminal output, supporting colors, boldness, and predefined styles.
â”‚   â”‚       ///
â”‚   â”‚       /// The `Label` struct allows you to create short, formatted text snippets, often
â”‚   â”‚       /// used for status indicators, categorization, or highlighting. It integrates
â”‚   â”‚       /// with `ansi_term` for rich terminal styling.
â”‚   â”‚       ///
â”‚   â”‚       /// # Examples
â”‚   â”‚       ///
â”‚   â”‚       /// Basic usage:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::Label;
â”‚   â”‚       ///
â”‚   â”‚       /// Label::new("SUCCESS").color("green").bold(true).print();
â”‚   â”‚       /// ```
â”‚   â”‚       ///
â”‚   â”‚       /// Using predefined styles:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::Label;
â”‚   â”‚       ///
â”‚   â”‚       /// Label::new("INFO").style("info").print();
â”‚   â”‚       /// Label::new("ERROR").style("error").print();
â”‚   â”‚       /// ```
â”‚   â”‚       ///
â”‚   â”‚       /// Getting an inline string:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::Label;
â”‚   â”‚       ///
â”‚   â”‚       /// let inline_label = Label::new("STATUS").color("yellow").inline();
â”‚   â”‚       /// println!("Current {}", inline_label);
â”‚   â”‚       /// ```
â”‚   â”‚       pub struct Label {
â”‚   â”‚           text: String,
â”‚   â”‚           color: Option<String>,
â”‚   â”‚           bold: bool,
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”‚       impl Label {
â”‚   â”‚           /// Creates a new `Label` instance with the specified text.
â”‚   â”‚           ///
â”‚   â”‚           /// The label is initially uncolored, not bold, and has no predefined style.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `text` - The string slice that will be displayed within the label.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// A new `Label` instance.
â”‚   â”‚           pub fn new(text: &str) -> Self {
â”‚   â”‚               Self {
â”‚   â”‚                   text: text.to_string(),
â”‚   â”‚                   color: None,
â”‚   â”‚                   bold: false,
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the foreground color of the label.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Label` instance,
â”‚   â”‚           /// allowing for method chaining. The color name should be one of the
â”‚   â”‚           /// supported names (e.g., "red", "blue", "green"). If an unsupported
â”‚   â”‚           /// color name is provided, the color will not be applied.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `color` - A string slice representing the desired color name.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Label` instance with the updated color setting.
â”‚   â”‚           pub fn color(mut self, color: &str) -> Self {
â”‚   â”‚               self.color = Some(color.to_string());
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets whether the label text should be bold.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Label` instance,
â”‚   â”‚           /// allowing for method chaining.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `bold` - A boolean value: `true` for bold text, `false` otherwise.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Label` instance with the updated bold setting.
â”‚   â”‚           pub fn bold(mut self, bold: bool) -> Self {
â”‚   â”‚               self.bold = bold;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Applies a predefined style to the label.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Label` instance,
â”‚   â”‚           /// allowing for method chaining. Predefined styles automatically set
â”‚   â”‚           /// color and/or boldness.
â”‚   â”‚           ///
â”‚   â”‚           /// Supported styles:
â”‚   â”‚           /// - "info": Sets color to blue and bold to true.
â”‚   â”‚           /// - "success": Sets color to green.
â”‚   â”‚           /// - "error": Sets color to red and bold to true.
â”‚   â”‚           ///
â”‚   â”‚           /// If an unsupported style name is provided, no changes are applied.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `style` - A string slice representing the predefined style name.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Label` instance with the applied style.
â”‚   â”‚           pub fn style(self, style: &str) -> Self {
â”‚   â”‚               match style {
â”‚   â”‚                   "info" => self.color("blue").bold(true),
â”‚   â”‚                   "success" => self.color("green"),
â”‚   â”‚                   "error" => self.color("red").bold(true),
â”‚   â”‚                   _ => self,
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Prints the formatted label to the console, enclosed in square brackets.
â”‚   â”‚           ///
â”‚   â”‚           /// The output will include ANSI escape codes for color and boldness if specified.
â”‚   â”‚           /// The label text will be formatted as `[TEXT]`.
â”‚   â”‚           ///
â”‚   â”‚           /// # Examples
â”‚   â”‚           ///
â”‚   â”‚           /// ```
â”‚   â”‚           /// use cliux::components::Label;
â”‚   â”‚           /// Label::new("Done").style("success").print(); // Prints "[Done]" in green
â”‚   â”‚           /// ```
â”‚   â”‚           pub fn print(&self) {
â”‚   â”‚               let mut style = ansi_term::Style::new();
â”‚   â”‚       
â”‚   â”‚               if let Some(ref color_name) = self.color {
â”‚   â”‚                   if let Some(colour) = parse_colour(color_name) {
â”‚   â”‚                       style = style.fg(colour);
â”‚   â”‚                   }
â”‚   â”‚               }
â”‚   â”‚       
â”‚   â”‚               if self.bold {
â”‚   â”‚                   style = style.bold();
â”‚   â”‚               }
â”‚   â”‚       
â”‚   â”‚               println!("{}", style.paint(format!("[{}]", self.text)));
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Returns the formatted label as an `ansi_term::ANSIGenericString`,
â”‚   â”‚           /// suitable for inline use within other `println!` or string operations.
â”‚   â”‚           ///
â”‚   â”‚           /// The returned string will include ANSI escape codes for color and boldness
â”‚   â”‚           /// if specified. The label text will be formatted as `[TEXT]`.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// A `String` containing the formatted label with ANSI escape codes.
â”‚   â”‚           ///
â”‚   â”‚           /// # Examples
â”‚   â”‚           ///
â”‚   â”‚           /// ```
â”‚   â”‚           /// use cliux::components::Label;
â”‚   â”‚           /// let status = Label::new("WARNING").color("yellow").inline();
â”‚   â”‚           /// println!("Operation Status: {}", status);
â”‚   â”‚           /// ```
â”‚   â”‚           pub fn inline(&self) -> String {
â”‚   â”‚               let mut style = ansi_term::Style::new();
â”‚   â”‚       
â”‚   â”‚               if let Some(ref color_name) = self.color {
â”‚   â”‚                   if let Some(colour) = parse_colour(color_name) {
â”‚   â”‚                       style = style.fg(colour);
â”‚   â”‚                   }
â”‚   â”‚               }
â”‚   â”‚       
â”‚   â”‚               if self.bold {
â”‚   â”‚                   style = style.bold();
â”‚   â”‚               }
â”‚   â”‚       
â”‚   â”‚               style.paint(format!("[{}]", self.text)).to_string()
â”‚   â”‚           }
â”‚   â”‚       }
â”‚   â”‚       --- FILE CONTENT END ---
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚       --- FILE CONTENT START ---
â”‚   â”‚       pub mod boxed;
â”‚   â”‚       pub mod divider;
â”‚   â”‚       pub mod section;
â”‚   â”‚       pub mod label;
â”‚   â”‚       
â”‚   â”‚       pub use boxed::Boxed;
â”‚   â”‚       pub use divider::Divider;
â”‚   â”‚       pub use section::Section;
â”‚   â”‚       pub use label::Label;
â”‚   â”‚       --- FILE CONTENT END ---
â”‚   â”‚   â””â”€â”€ section.rs
â”‚   â”‚       --- FILE CONTENT START ---
â”‚   â”‚       use crate::layout::{pad, wrap_text};
â”‚   â”‚       
â”‚   â”‚       /// A titled block of content, often used for organizing information
â”‚   â”‚       /// with a preceding title and a divider.
â”‚   â”‚       ///
â”‚   â”‚       /// The `Section` struct provides a way to present blocks of text with a clear
â”‚   â”‚       /// title and an optional horizontal separator. It supports intelligent text
â”‚   â”‚       /// wrapping to fit content within a specified width.
â”‚   â”‚       ///
â”‚   â”‚       /// # Examples
â”‚   â”‚       ///
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::Section;
â”‚   â”‚       ///
â”‚   â”‚       /// Section::new("Introduction")
â”‚   â”‚       ///     .content("This is the beginning of a new section. It can have some introductory text.")
â”‚   â”‚       ///     .width(60)
â”‚   â”‚       ///     .print();
â”‚   â”‚       ///
â”‚   â”‚       /// Section::new("Long Text Section")
â”‚   â”‚       ///     .content("This is a very long sentence that needs to be wrapped intelligently across multiple lines so that it fits neatly within the terminal output and doesn't overflow its boundaries.")
â”‚   â”‚       ///     .width(40)
â”‚   â”‚       ///     .wrap(true)
â”‚   â”‚       ///     .style('=')
â”‚   â”‚       ///     .print();
â”‚   â”‚       /// ```
â”‚   â”‚       pub struct Section {
â”‚   â”‚           title: String,
â”‚   â”‚           content: String,
â”‚   â”‚           width: usize,
â”‚   â”‚           style: char,
â”‚   â”‚           wrap: bool,
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”‚       impl Section {
â”‚   â”‚           /// Creates a new `Section` instance with the given title.
â”‚   â”‚           ///
â”‚   â”‚           /// By default, the section will have no content, a width of 50 characters,
â”‚   â”‚           /// a default divider style of `'â”€'`, and text wrapping disabled.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `title` - The title of the section.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// A new `Section` instance.
â”‚   â”‚           pub fn new(title: &str) -> Self {
â”‚   â”‚               Self {
â”‚   â”‚                   title: title.to_string(),
â”‚   â”‚                   content: String::new(),
â”‚   â”‚                   width: 50,
â”‚   â”‚                   style: 'â”€',
â”‚   â”‚                   wrap: false,
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the main content of the section.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Section` instance,
â”‚   â”‚           /// allowing for method chaining. Newline characters (`\n`) in the content
â”‚   â”‚           /// will create new paragraphs or line breaks within the section.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `text` - The string slice containing the content for the section.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Section` instance with the updated content.
â”‚   â”‚           pub fn content(mut self, text: &str) -> Self {
â”‚   â”‚               self.content = text.to_string();
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the total width of the section's content and divider.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Section` instance,
â”‚   â”‚           /// allowing for method chaining. The content will be padded or wrapped
â”‚   â”‚           /// to fit this width.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `width` - The desired total width of the section in characters.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Section` instance with the updated width.
â”‚   â”‚           pub fn width(mut self, width: usize) -> Self {
â”‚   â”‚               self.width = width;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the character used for the horizontal divider within the section.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Section` instance,
â”‚   â”‚           /// allowing for method chaining.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `style` - The character to use for the divider (e.g., `'='`, `'-'`, `'*'`).
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Section` instance with the updated style.
â”‚   â”‚           pub fn style(mut self, style: char) -> Self {
â”‚   â”‚               self.style = style;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Enables or disables intelligent text wrapping for the content within the section.
â”‚   â”‚           ///
â”‚   â”‚           /// If `true`, long lines of content will be wrapped to fit the specified `width`
â”‚   â”‚           /// at word boundaries. If `false` (default), lines will only break at explicit
â”‚   â”‚           /// newline characters (`\n`).
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Section` instance,
â”‚   â”‚           /// allowing for method chaining.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `wrap` - A boolean indicating whether to enable (`true`) or disable (`false`) text wrapping.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Section` instance with the updated wrap setting.
â”‚   â”‚           pub fn wrap(mut self, wrap: bool) -> Self {
â”‚   â”‚               self.wrap = wrap;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Prints the `Section` to the console.
â”‚   â”‚           ///
â”‚   â”‚           /// This method renders the section, including its title, a horizontal
â”‚   â”‚           /// divider, and its content (with optional wrapping and padding),
â”‚   â”‚           /// to standard output.
â”‚   â”‚           pub fn print(&self) {
â”‚   â”‚               println!("{}:", self.title);
â”‚   â”‚               println!("{}", self.style.to_string().repeat(self.width));
â”‚   â”‚               let lines = if self.wrap {
â”‚   â”‚                   wrap_text(&self.content, self.width)
â”‚   â”‚               } else {
â”‚   â”‚                   self.content.lines().map(|l| l.to_string()).collect()
â”‚   â”‚               };
â”‚   â”‚       
â”‚   â”‚               for line in lines {
â”‚   â”‚                   println!("{}", pad(&line, self.width));
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       }
â”‚   â”‚       --- FILE CONTENT END ---
â”‚   â”œâ”€â”€ layout.rs
â”‚       --- FILE CONTENT START ---
â”‚       use unicode_segmentation::UnicodeSegmentation;
â”‚       use unicode_width::UnicodeWidthStr;
â”‚       
â”‚       /// Pads the given `text` with spaces on the right to reach the specified `width`.
â”‚       ///
â”‚       /// This function is Unicode-aware, correctly handling multi-byte characters like emojis
â”‚       /// by considering their display width rather than byte length.
â”‚       ///
â”‚       /// # Arguments
â”‚       ///
â”‚       /// * `text` - The string slice to pad.
â”‚       /// * `width` - The desired total width of the padded string.
â”‚       ///
â”‚       /// # Returns
â”‚       ///
â”‚       /// A `String` containing the original text padded to the specified width.
â”‚       ///
â”‚       /// # Examples
â”‚       ///
â”‚       /// ```
â”‚       /// use cliux::layout::pad;
â”‚       /// assert_eq!(pad("Hello", 10), "Hello     ");
â”‚       /// assert_eq!(pad("ğŸ‘‹", 5), "ğŸ‘‹   "); // Assuming emoji width 2
â”‚       /// assert_eq!(pad("Rust", 3), "Rust"); // No padding if width is less than or equal to text width
â”‚       /// ```
â”‚       pub fn pad(text: &str, width: usize) -> String {
â”‚           let graphemes = UnicodeSegmentation::graphemes(text, true);
â”‚           let mut display_width = 0;
â”‚       
â”‚           for g in graphemes {
â”‚               let w = g.width();
â”‚               let adjusted = if is_emoji(g) && w == 1 { 2 } else { w };
â”‚               display_width += adjusted;
â”‚           }
â”‚       
â”‚           let padding = width.saturating_sub(display_width);
â”‚           format!("{}{}", text, " ".repeat(padding))
â”‚       }
â”‚       
â”‚       fn is_emoji(g: &str) -> bool {
â”‚           g.chars().any(|c| {
â”‚               let code = c as u32;
â”‚               (code >= 0x1F300 && code <= 0x1FAFF) || (code >= 0x2600 && code <= 0x26FF)
â”‚           })
â”‚       }
â”‚       
â”‚       /// Wraps the given `text` into a vector of strings, ensuring that each line
â”‚       /// does not exceed the specified `width`.
â”‚       ///
â”‚       /// The wrapping is done intelligently, breaking at word boundaries.
â”‚       /// Paragraphs are maintained by processing `text` line by line.
â”‚       ///
â”‚       /// # Arguments
â”‚       ///
â”‚       /// * `text` - The string slice to wrap.
â”‚       /// * `width` - The maximum desired width for each wrapped line.
â”‚       ///
â”‚       /// # Returns
â”‚       ///
â”‚       /// A `Vec<String>` where each element is a wrapped line of the original text.
â”‚       ///
â”‚       /// # Examples
â”‚       ///
â”‚       /// ```
â”‚       /// use cliux::layout::wrap_text;
â”‚       /// let long_text = "This is a very long sentence that needs to be wrapped.";
â”‚       /// let wrapped_lines = wrap_text(long_text, 20);
â”‚       /// assert_eq!(wrapped_lines, vec![
â”‚       ///     "This is a very",
â”‚       ///     "long sentence that",
â”‚       ///     "needs to be wrapped."
â”‚       /// ]);
â”‚       ///
â”‚       /// let paragraph_text = "First paragraph.\nSecond paragraph is a bit longer and needs wrapping.";
â”‚       /// let wrapped_paragraphs = wrap_text(paragraph_text, 25);
â”‚       /// assert_eq!(wrapped_paragraphs, vec![
â”‚       ///     "First paragraph.",
â”‚       ///     "Second paragraph is a",
â”‚       ///     "bit longer and needs",
â”‚       ///     "wrapping."
â”‚       /// ]);
â”‚       /// ```
â”‚       pub fn wrap_text(text: &str, width: usize) -> Vec<String> {
â”‚           let mut lines = Vec::new();
â”‚           for paragraph in text.lines() {
â”‚               let mut current = String::new();
â”‚               for word in paragraph.split_whitespace() {
â”‚                   if current.len() + word.len() + 1 > width {
â”‚                       lines.push(current.trim_end().to_string());
â”‚                       current.clear();
â”‚                   }
â”‚                   current.push_str(word);
â”‚                   current.push(' ');
â”‚               }
â”‚               if !current.is_empty() {
â”‚                   lines.push(current.trim_end().to_string());
â”‚               }
â”‚           }
â”‚           lines
â”‚       }
â”‚       --- FILE CONTENT END ---
â”‚   â””â”€â”€ lib.rs
â”‚       --- FILE CONTENT START ---
â”‚       //! # cliux
â”‚       //!
â”‚       //! `cliux` is a lightweight Rust crate for formatting terminal output with clean, readable components â€” no TUI required.
â”‚       //! It helps CLI tools present information with structure and style using boxes, sections, dividers, and smart padding.
â”‚       
â”‚       pub mod components;
â”‚       pub mod layout;
â”‚       
â”‚       /// Re-exports the `Boxed` struct from the `components` module.
â”‚       pub use components::Boxed;
â”‚       /// Re-exports the `Divider` struct from the `components` module.
â”‚       pub use components::Divider;
â”‚       /// Re-exports the `Label` struct from the `components` module.
â”‚       pub use components::Label;
â”‚       /// Re-exports the `Section` struct from the `components` module.
â”‚       pub use components::Section;
â”‚       --- FILE CONTENT END ---
â”œâ”€â”€ .gitignore
    --- FILE CONTENT START ---
    /target
    --- FILE CONTENT END ---
â”œâ”€â”€ Cargo.lock
    --- FILE CONTENT START ---
    # This file is automatically @generated by Cargo.
    # It is not intended for manual editing.
    version = 4
    
    [[package]]
    name = "ansi_term"
    version = "0.12.1"
    source = "registry+https://github.com/rust-lang/crates.io-index"
    checksum = "d52a9bb7ec0cf484c551830a7ce27bd20d67eac647e1befb56b0be4ee39a55d2"
    dependencies = [
     "winapi",
    ]
    
    [[package]]
    name = "cliux"
    version = "0.1.3"
    dependencies = [
     "ansi_term",
     "unicode-segmentation",
     "unicode-width",
    ]
    
    [[package]]
    name = "unicode-segmentation"
    version = "1.12.0"
    source = "registry+https://github.com/rust-lang/crates.io-index"
    checksum = "f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493"
    
    [[package]]
    name = "unicode-width"
    version = "0.1.14"
    source = "registry+https://github.com/rust-lang/crates.io-index"
    checksum = "7dd6e30e90baa6f72411720665d41d89b9a3d039dc45b8faea1ddd07f617f6af"
    
    [[package]]
    name = "winapi"
    version = "0.3.9"
    source = "registry+https://github.com/rust-lang/crates.io-index"
    checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
    dependencies = [
     "winapi-i686-pc-windows-gnu",
     "winapi-x86_64-pc-windows-gnu",
    ]
    
    [[package]]
    name = "winapi-i686-pc-windows-gnu"
    version = "0.4.0"
    source = "registry+https://github.com/rust-lang/crates.io-index"
    checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
    
    [[package]]
    name = "winapi-x86_64-pc-windows-gnu"
    version = "0.4.0"
    source = "registry+https://github.com/rust-lang/crates.io-index"
    checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
    --- FILE CONTENT END ---
â”œâ”€â”€ Cargo.toml
    --- FILE CONTENT START ---
    [package]
    name = "cliux"
    version = "0.1.3"
    edition = "2024"
    license = "MIT"
    authors = ["Pjdur"]
    repository = "https://github.com/Pjdur/cliux"
    description = "Styled terminal output made simple â€” boxes, sections, dividers, and emoji-aware padding for CLI tools."
    
    [dependencies]
    ansi_term = "0.12.1"
    unicode-segmentation = "1.10"
    unicode-width = "0.1"
    --- FILE CONTENT END ---
â”œâ”€â”€ CHANGELOG.md
    --- FILE CONTENT START ---
    # Changelog
    
    All notable changes to this project will be documented here.
    
    ## [0.1.3] - 2025-10-31
    
    - Added inline documentation for all public methods and properties
    - Improved contributor onboarding with `CONTRIBUTING.md`
    - Updated changelog and published docs to docs.rs
    
    ## [0.1.2] - 2025-10-30
    ### Added
    - `.wrap()` support for `Section`
    - Animated GIF demos for `Boxed`, `Section`, and `Divider`
    
    ### Improved
    - README examples and visuals
    
    ## [0.1.1] - 2025-10-30
    ### Added
    - `.style()` method for `Section` for custom divider characters
    
    ## [0.1.0] - 2025-10-30
    Initial release
    --- FILE CONTENT END ---
â”œâ”€â”€ CONTRIBUTING.md
    --- FILE CONTENT START ---
    # Contributing to cliux
    
    Thanks for your interest in contributing!
    
    ## Getting Started
    
    1. Clone the repo and run examples in `/examples`
    2. Use `cargo test` to run unit tests
    3. Use `cargo doc --open` to preview documentation
    
    ## Suggestions Welcome
    
    Feel free to open issues for:
    - New components (e.g. Label, Table)
    - Styling features (e.g. color support)
    - Layout improvements or edge cases
    
    ## Code Style
    
    - Use idiomatic Rust
    - Document public APIs with `///` comments
    - Keep components focused and composable
    
    Pull requests are welcome!
    --- FILE CONTENT END ---
â”œâ”€â”€ LICENSE
    --- FILE CONTENT START ---
    Copyright 2025 Pjdur
    
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the â€œSoftwareâ€), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED â€œAS ISâ€, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    --- FILE CONTENT END ---
â””â”€â”€ README.md
    --- FILE CONTENT START ---
    # cliux
    
    **Styled terminal output made simple.**
    
    `cliux` is a lightweight Rust crate for formatting terminal output with clean, readable components â€” no TUI required. It helps CLI tools present information with structure and style using boxes, sections, dividers, and smart padding.
    
    ## âœ¨ Features
    
    - ğŸ“¦ `Boxed` â€” bordered containers with titles and content
    - ğŸ“„ `Section` â€” titled blocks with horizontal dividers
    - â”€ `Divider` â€” customizable horizontal lines
    - ğŸ§  Unicode-aware padding (emoji-safe)
    
    ## Examples
    
    ### ğŸ“¦ Boxed
    
    ```rust
    use cliux::Boxed;
    
    fn main() {
        Boxed::new("Cliux Boxed")
            .content("This code uses the cliux library to create a boxed section.")
            .width(61)
            .print();
    }
    ```
    
    ### ğŸ·ï¸ Label
    
    ```rust
    use cliux::Label;
    
    fn main() {
        Label::new("INFO").style("info").print();
        Label::new("âœ“ Done").style("success").print();
        Label::new("ERROR").style("error").print();
    }
    ```
    ### ğŸ“„ Section
    
    ```rust
    use cliux::Section;
    
    fn main() {
        Section::new("Wrapped Section")
            .content("This is a long sentence that will be wrapped intelligently across multiple lines.")
            .width(40)
            .wrap(true)
            .style('â”€')
            .print();
    }
    ```
    
    ### â”€ Divider
    
    ```rust
    use cliux::Divider;
    
    fn main() {
        Divider::new(30).style('=').print();
    }
    ```
    
    ## ğŸ“š Usage
    
    Add to your `Cargo.toml`:
    
    ```toml
    cliux = "0.1.2"
    ```
    
    ## Screenshots
    
    ### ğŸ“¦ Boxed
    
    ![Boxed](assets/boxed.gif)
    
    ### ğŸ·ï¸ Label
    
    ![Label](assets/label.gif)
    
    ### ğŸ“„ Section
    
    ![Section](assets/section.gif)
    
    ### â”€ Divider
    
    ![Divider](assets/divider.gif)
    
    ## ğŸš§ Status
    
    This is an early release. Components and layout may evolve. Contributions and feedback welcome!
    --- FILE CONTENT END ---
