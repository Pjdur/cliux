cliux
â”œâ”€â”€ assets/
â”‚   â”œâ”€â”€ boxed.gif
â”‚       [Could not read file: stream did not contain valid UTF-8]
â”‚   â”œâ”€â”€ divider.gif
â”‚       [Could not read file: stream did not contain valid UTF-8]
â”‚   â”œâ”€â”€ label.gif
â”‚       [Could not read file: stream did not contain valid UTF-8]
â”‚   â”œâ”€â”€ list.gif
â”‚       [Could not read file: stream did not contain valid UTF-8]
â”‚   â”œâ”€â”€ note.cast
â”‚       --- FILE CONTENT START ---
â”‚       {"version":2,"width":114,"height":13,"timestamp":1762363288,"env":{"TERM":"xterm-256color","SHELL":"powershell.exe"}}
â”‚       [0.28980469703674316,"o","\u001b[?25l\u001b[2J\u001b[m\u001b[HWindows PowerShell\r\nCopyright (C) Microsoft Corporation. All rights reserved.\u001b[4;1HInstall the latest PowerShell for new features and improvements! https://aka.ms/PSWindows\u001b[6;1H\u001b]0;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\u0007\u001b[?25h"]
â”‚       [0.6647684574127197,"o","PS D:\\cliux> "]
â”‚       [1.1994004249572754,"o","\u001b[93mc"]
â”‚       [1.2143187522888184,"o","\u001b[m"]
â”‚       [1.258467435836792,"o","\u001b[93m\bcl"]
â”‚       [1.2741179466247559,"o","\u001b[m"]
â”‚       [1.368086576461792,"o","\u001b[?25l\u001b[93m\u001b[6;14Hcls\u001b[?25h"]
â”‚       [1.3837800025939941,"o","\u001b[m"]
â”‚       [1.524888277053833,"o","\r\n"]
â”‚       [1.5713679790496826,"o","\u001b[?25l\u001b[3J\u001b[H\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\u001b[H\u001b[?25h"]
â”‚       [1.6189372539520264,"o","PS D:\\cliux> "]
â”‚       [2.8207461833953857,"o","\u001b[93mc"]
â”‚       [2.836695909500122,"o","\u001b[m"]
â”‚       [3.0083792209625244,"o","\u001b[93m\bca"]
â”‚       [3.028982162475586,"o","\u001b[m"]
â”‚       [3.211700916290283,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcar\u001b[?25h"]
â”‚       [3.2307443618774414,"o","\u001b[m"]
â”‚       [3.3991503715515137,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcarg\u001b[?25h"]
â”‚       [3.414424180984497,"o","\u001b[m"]
â”‚       [3.513435125350952,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo\u001b[?25h"]
â”‚       [3.5241634845733643,"o","\u001b[m"]
â”‚       [3.680567979812622,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[?25h"]
â”‚       [3.6958186626434326,"o","\u001b[m"]
â”‚       [3.763984203338623,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mr\u001b[?25h"]
â”‚       [3.8849387168884277,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mru\u001b[?25h"]
â”‚       [4.3209569454193115,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun\u001b[?25h"]
â”‚       [4.492588996887207,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[?25h"]
â”‚       [4.729205369949341,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun -\u001b[?25h"]
â”‚       [4.887994766235352,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--\u001b[?25h"]
â”‚       [4.919428825378418,"o","\u001b[m"]
â”‚       [4.991772890090942,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--e\u001b[?25h"]
â”‚       [5.007662773132324,"o","\u001b[m"]
â”‚       [5.492095232009888,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--ex\u001b[?25h"]
â”‚       [5.512484788894653,"o","\u001b[m"]
â”‚       [5.679957628250122,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--exa\u001b[?25h"]
â”‚       [5.699928283691406,"o","\u001b[m"]
â”‚       [5.773168325424194,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--exam\u001b[?25h"]
â”‚       [5.813159227371216,"o","\u001b[m"]
â”‚       [5.960678339004517,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--examp\u001b[?25h"]
â”‚       [5.976335048675537,"o","\u001b[m"]
â”‚       [6.183069467544556,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--exampe\u001b[?25h"]
â”‚       [6.195231199264526,"o","\u001b[m"]
â”‚       [6.42952299118042,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--examp \b\u001b[?25h"]
â”‚       [6.4452736377716064,"o","\u001b[m"]
â”‚       [6.585639238357544,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--exampl\u001b[?25h"]
â”‚       [6.604814052581787,"o","\u001b[m"]
â”‚       [6.663663387298584,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--example\u001b[?25h"]
â”‚       [6.6839759349823,"o","\u001b[m"]
â”‚       [6.757733583450317,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--example \u001b[?25h"]
â”‚       [6.77305793762207,"o","\u001b[m"]
â”‚       [6.898152828216553,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--example \u001b[mn\u001b[?25h"]
â”‚       [7.070188283920288,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--example \u001b[mno\u001b[?25h"]
â”‚       [7.148147344589233,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--example \u001b[mnot\u001b[?25h"]
â”‚       [7.742279291152954,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--example \u001b[mnote\u001b[?25h"]
â”‚       [8.166410684585571,"o","\r\n"]
â”‚       [8.569990158081055,"o","\u001b[32m\u001b[1m    Finished\u001b[m `dev` profile [unoptimized + debuginfo] target(s) in 0.10s\u001b[32m\u001b[1m\r\n     Running\u001b[m `target\\debug\\examples\\note.exe`\r\n"]
â”‚       [8.913297414779663,"o","â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\r\nâ”‚ âš ï¸ Be careful with this setting.     â”‚\r\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\r\n+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€+\r\n| ðŸ’¡ Tip: You can use --force here.    |\r\n+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€+\r\n"]
â”‚       [8.929112195968628,"o","PS D:\\cliux> "]
â”‚       [9.897683382034302,"o","\u001b[93me"]
â”‚       [9.913358688354492,"o","\u001b[m"]
â”‚       [10.085402011871338,"o","\u001b[93m\bex"]
â”‚       [10.105115413665771,"o","\u001b[m"]
â”‚       [10.210665702819824,"o","\u001b[?25l\u001b[93m\u001b[10;14Hexi\u001b[?25h"]
â”‚       [10.240496397018433,"o","\u001b[m"]
â”‚       [10.429342031478882,"o","\u001b[?25l\u001b[92m\u001b[10;14Hexit\u001b[?25h"]
â”‚       [10.44578242301941,"o","\u001b[m"]
â”‚       [10.679314136505127,"o","\r\n"]
â”‚       --- FILE CONTENT END ---
â”‚   â”œâ”€â”€ note.gif
â”‚       [Could not read file: stream did not contain valid UTF-8]
â”‚   â”œâ”€â”€ section.gif
â”‚       [Could not read file: stream did not contain valid UTF-8]
â”‚   â”œâ”€â”€ table.cast
â”‚       --- FILE CONTENT START ---
â”‚       {"version":2,"width":114,"height":13,"timestamp":1762363256,"env":{"SHELL":"powershell.exe","TERM":"xterm-256color"}}
â”‚       [0.27774930000305176,"o","\u001b[?25l\u001b[2J\u001b[m\u001b[HWindows PowerShell\r\nCopyright (C) Microsoft Corporation. All rights reserved.\u001b[4;1HInstall the latest PowerShell for new features and improvements! https://aka.ms/PSWindows\u001b[6;1H\u001b]0;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\u0007\u001b[?25h"]
â”‚       [0.6370391845703125,"o","PS D:\\cliux> "]
â”‚       [1.187117338180542,"o","\u001b[93mc"]
â”‚       [1.1996345520019531,"o","\u001b[m"]
â”‚       [1.2630376815795898,"o","\u001b[93m\bcl"]
â”‚       [1.277867078781128,"o","\u001b[m"]
â”‚       [1.371610164642334,"o","\u001b[?25l\u001b[93m\u001b[6;14Hcls\u001b[?25h"]
â”‚       [1.3871970176696777,"o","\u001b[m"]
â”‚       [1.496412992477417,"o","\r\n"]
â”‚       [1.5439047813415527,"o","\u001b[?25l\u001b[3J\u001b[H\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\u001b[H\u001b[?25h"]
â”‚       [1.5666885375976562,"o","\u001b[?25l\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\r\n\u001b[K\u001b[H\u001b[?25h"]
â”‚       [1.5904278755187988,"o","PS D:\\cliux> "]
â”‚       [1.8561577796936035,"o","\u001b[93mc"]
â”‚       [1.872072458267212,"o","\u001b[m"]
â”‚       [2.0750021934509277,"o","\u001b[93m\bca"]
â”‚       [2.090477228164673,"o","\u001b[m"]
â”‚       [2.2627859115600586,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcar\u001b[?25h"]
â”‚       [2.2870779037475586,"o","\u001b[m"]
â”‚       [2.43717098236084,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcarg\u001b[?25h"]
â”‚       [2.449786424636841,"o","\u001b[m"]
â”‚       [2.5439653396606445,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo\u001b[?25h"]
â”‚       [2.559324026107788,"o","\u001b[m"]
â”‚       [2.7314867973327637,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[?25h"]
â”‚       [2.7469537258148193,"o","\u001b[m"]
â”‚       [2.8251233100891113,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mr\u001b[?25h"]
â”‚       [2.935922384262085,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mru\u001b[?25h"]
â”‚       [3.1220762729644775,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun\u001b[?25h"]
â”‚       [3.5440187454223633,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[?25h"]
â”‚       [3.8416247367858887,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun -\u001b[?25h"]
â”‚       [3.9820821285247803,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--\u001b[?25h"]
â”‚       [3.997410774230957,"o","\u001b[m"]
â”‚       [4.1696882247924805,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--e\u001b[?25h"]
â”‚       [4.185812473297119,"o","\u001b[m"]
â”‚       [4.35723876953125,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--ex\u001b[?25h"]
â”‚       [4.3724894523620605,"o","\u001b[m"]
â”‚       [4.544981002807617,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--exa\u001b[?25h"]
â”‚       [4.570948600769043,"o","\u001b[m"]
â”‚       [4.609961032867432,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--exam\u001b[?25h"]
â”‚       [4.625354290008545,"o","\u001b[m"]
â”‚       [4.794369697570801,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--examp\u001b[?25h"]
â”‚       [4.809993743896484,"o","\u001b[m"]
â”‚       [4.966927766799927,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--exampl\u001b[?25h"]
â”‚       [5.005012273788452,"o","\u001b[m"]
â”‚       [5.060893774032593,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--example\u001b[?25h"]
â”‚       [5.075783967971802,"o","\u001b[m"]
â”‚       [5.184993743896484,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--example \u001b[?25h"]
â”‚       [5.203546524047852,"o","\u001b[m"]
â”‚       [5.279328346252441,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--example \u001b[mt\u001b[?25h"]
â”‚       [5.49797511100769,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--example \u001b[mta\u001b[?25h"]
â”‚       [5.560367584228516,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--example \u001b[mtab\u001b[?25h"]
â”‚       [5.763465404510498,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--example \u001b[mtabl\u001b[?25h"]
â”‚       [5.888219118118286,"o","\u001b[?25l\u001b[93m\u001b[1;14Hcargo \u001b[mrun \u001b[90m--example \u001b[mtable\u001b[?25h"]
â”‚       [6.028880596160889,"o","\r\n"]
â”‚       [6.419597625732422,"o","\u001b[32m\u001b[1m    Finished\u001b[m `dev` profile [unoptimized + debuginfo] target(s) in 0.11s\u001b[32m\u001b[1m\r\n     Running\u001b[m `target\\debug\\examples\\table.exe`\r\n"]
â”‚       [6.732205152511597,"o","+--------------------+----------+\r\n| Name               | Status   |\r\n+--------------------+----------+\r\n| cliux              | active   |\r\n| other              | pending  |\r\n+--------------------+----------+\r\n"]
â”‚       [6.748462915420532,"o","PS D:\\cliux> "]
â”‚       [7.763109445571899,"o","\u001b[93me"]
â”‚       [7.778758764266968,"o","\u001b[m"]
â”‚       [7.951489448547363,"o","\u001b[93m\bex"]
â”‚       [7.966242790222168,"o","\u001b[m"]
â”‚       [8.04464602470398,"o","\u001b[?25l\u001b[93m\u001b[10;14Hexi\u001b[?25h"]
â”‚       [8.060189723968506,"o","\u001b[m"]
â”‚       [8.185110330581665,"o","\u001b[?25l\u001b[92m\u001b[10;14Hexit\u001b[?25h"]
â”‚       [8.203560590744019,"o","\u001b[m"]
â”‚       [8.37264108657837,"o","\r\n"]
â”‚       --- FILE CONTENT END ---
â”‚   â”œâ”€â”€ table.gif
â”‚       [Could not read file: stream did not contain valid UTF-8]
â”‚   â””â”€â”€ tag.gif
â”‚       [Could not read file: stream did not contain valid UTF-8]
â”œâ”€â”€ examples/
â”‚   â”œâ”€â”€ boxed.rs
â”‚       --- FILE CONTENT START ---
â”‚       use cliux::Boxed;
â”‚       
â”‚       fn main() {
â”‚           Boxed::new("Cliux Boxed")
â”‚               .content("This code uses the cliux library to create a boxed section.")
â”‚               .width(61)
â”‚               .print();
â”‚       }
â”‚       --- FILE CONTENT END ---
â”‚   â”œâ”€â”€ divider.rs
â”‚       --- FILE CONTENT START ---
â”‚       use cliux::Divider;
â”‚       
â”‚       fn main() {
â”‚           Divider::new(20).print();
â”‚       }
â”‚       --- FILE CONTENT END ---
â”‚   â”œâ”€â”€ label.rs
â”‚       --- FILE CONTENT START ---
â”‚       use cliux::Label;
â”‚       
â”‚       fn main() {
â”‚           Label::new("INFO").style("info").print();
â”‚           Label::new("âœ“ Done").style("success").print();
â”‚           Label::new("ERROR").style("error").print();
â”‚       
â”‚           let inline = Label::new("DEBUG").color("cyan").bold(true).inline();
â”‚           println!("Inline label: {}", inline);
â”‚       }
â”‚       --- FILE CONTENT END ---
â”‚   â”œâ”€â”€ list.rs
â”‚       --- FILE CONTENT START ---
â”‚       use cliux::List;
â”‚       
â”‚       fn main() {
â”‚           List::new(vec!["First item", "Second item", "Third item"])
â”‚               .bullet("*")
â”‚               .width(40)
â”‚               .print();
â”‚       
â”‚           List::new(vec!["One", "Two", "Three"])
â”‚               .numbered()
â”‚               .print();
â”‚       }
â”‚       --- FILE CONTENT END ---
â”‚   â”œâ”€â”€ note.rs
â”‚       --- FILE CONTENT START ---
â”‚       use cliux::Note;
â”‚       
â”‚       fn main() {
â”‚           Note::new("Be careful with this setting.")
â”‚               .kind("warning")
â”‚               .style("rounded")
â”‚               .width(40)
â”‚               .print();
â”‚       
â”‚           Note::new("Tip: You can use --force here.")
â”‚               .kind("info")
â”‚               .style("+")
â”‚               .width(40)
â”‚               .print();
â”‚       }
â”‚       --- FILE CONTENT END ---
â”‚   â”œâ”€â”€ section.rs
â”‚       --- FILE CONTENT START ---
â”‚       use cliux::Section;
â”‚       
â”‚       fn main() {
â”‚           // Section using default style 'â”€'
â”‚           Section::new("Section #1")
â”‚               .content("This is the content of the section.")
â”‚               .print();
â”‚       
â”‚           // Section using custom style '-'
â”‚           Section::new("Section #2")
â”‚               .content("This is the content of the section.")
â”‚               .style('-')
â”‚               .wrap(true)
â”‚               .print();
â”‚       
â”‚           // Section with .wrap(true)
â”‚           Section::new("Section #3")
â”‚               .content(
â”‚                   "This is a long sentence that will be wrapped intelligently across multiple lines.",
â”‚               )
â”‚               .wrap(true)
â”‚               .print();
â”‚       }
â”‚       --- FILE CONTENT END ---
â”‚   â”œâ”€â”€ table.rs
â”‚       --- FILE CONTENT START ---
â”‚       use cliux::Table;
â”‚       
â”‚       fn main() {
â”‚           Table::new()
â”‚               .headers(&["Name", "Status"])
â”‚               .row(&["cliux", "active"])
â”‚               .row(&["other", "pending"])
â”‚               .widths(&[20, 10])
â”‚               .bordered(true)
â”‚               .print();
â”‚       }
â”‚       --- FILE CONTENT END ---
â”‚   â””â”€â”€ tag.rs
â”‚       --- FILE CONTENT START ---
â”‚       use cliux::Tag;
â”‚       
â”‚       fn main() {
â”‚           Tag::new("beta").rounded().color("yellow").bold(true).print();
â”‚           Tag::new("admin").curly().color("red").print();
â”‚           Tag::new("draft").print();
â”‚       }
â”‚       --- FILE CONTENT END ---
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ boxed.rs
â”‚   â”‚       --- FILE CONTENT START ---
â”‚   â”‚       use crate::layout::pad;
â”‚   â”‚       
â”‚   â”‚       /// A bordered container for displaying content with a title.
â”‚   â”‚       ///
â”‚   â”‚       /// `Boxed` allows you to present information within a visually distinct
â”‚   â”‚       /// box in the terminal, complete with a title and multi-line content.
â”‚   â”‚       ///
â”‚   â”‚       /// # Examples
â”‚   â”‚       ///
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::Boxed;
â”‚   â”‚       ///
â”‚   â”‚       /// Boxed::new("Important Notice")
â”‚   â”‚       ///     .content("This is a message inside a box.\nIt can span multiple lines.")
â”‚   â”‚       ///     .width(60)
â”‚   â”‚       ///     .print();
â”‚   â”‚       /// ```
â”‚   â”‚       pub struct Boxed {
â”‚   â”‚           title: String,
â”‚   â”‚           content: String,
â”‚   â”‚           width: usize,
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”‚       impl Boxed {
â”‚   â”‚           /// Creates a new `Boxed` instance with the given title.
â”‚   â”‚           ///
â”‚   â”‚           /// The default width is 50 characters, and the content is initially empty.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `title` - The title to display at the top of the box.
â”‚   â”‚           pub fn new(title: &str) -> Self {
â”‚   â”‚               Self {
â”‚   â”‚                   title: title.to_string(),
â”‚   â”‚                   content: String::new(),
â”‚   â”‚                   width: 50,
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the main content of the box.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Boxed` instance,
â”‚   â”‚           /// allowing for method chaining. Newline characters (`\n`) in the
â”‚   â”‚           /// content will create new lines within the box.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `text` - The string slice containing the content for the box.
â”‚   â”‚           pub fn content(mut self, text: &str) -> Self {
â”‚   â”‚               self.content = text.to_string();
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the total width of the box, including borders.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Boxed` instance,
â”‚   â”‚           /// allowing for method chaining. The content and title will be
â”‚   â”‚           /// padded to fit this width.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `width` - The desired total width of the box in characters.
â”‚   â”‚           pub fn width(mut self, width: usize) -> Self {
â”‚   â”‚               self.width = width;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Prints the `Boxed` content to the console.
â”‚   â”‚           ///
â”‚   â”‚           /// This method renders the box with its title, borders, and content
â”‚   â”‚           /// to standard output.
â”‚   â”‚           pub fn print(&self) {
â”‚   â”‚               println!("â•­{:â”€<1$}â•®", "", self.width);
â”‚   â”‚               println!("â”‚ {} â”‚", pad(&self.title, self.width - 2));
â”‚   â”‚               println!("â”œ{:â”€<1$}â”¤", "", self.width);
â”‚   â”‚               for line in self.content.lines() {
â”‚   â”‚                   println!("â”‚ {} â”‚", pad(line, self.width - 2));
â”‚   â”‚               }
â”‚   â”‚               println!("â•°{:â”€<1$}â•¯", "", self.width);
â”‚   â”‚           }
â”‚   â”‚       }
â”‚   â”‚       --- FILE CONTENT END ---
â”‚   â”‚   â”œâ”€â”€ divider.rs
â”‚   â”‚       --- FILE CONTENT START ---
â”‚   â”‚       /// A customizable horizontal line for separating sections of output.
â”‚   â”‚       ///
â”‚   â”‚       /// The `Divider` struct allows you to easily create horizontal rules
â”‚   â”‚       /// in your terminal output, useful for visually separating different
â”‚   â”‚       /// parts of information. You can customize its width and the character
â”‚   â”‚       /// used to draw it.
â”‚   â”‚       ///
â”‚   â”‚       /// # Examples
â”‚   â”‚       ///
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::Divider;
â”‚   â”‚       ///
â”‚   â”‚       /// // A default divider of 50 characters
â”‚   â”‚       /// Divider::new(50).print();
â”‚   â”‚       ///
â”‚   â”‚       /// // A divider using '=' characters
â”‚   â”‚       /// Divider::new(30).style('=').print();
â”‚   â”‚       /// ```
â”‚   â”‚       pub struct Divider {
â”‚   â”‚           width: usize,
â”‚   â”‚           style: char, // e.g. 'â”€', '=', '.', etc.
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”‚       impl Divider {
â”‚   â”‚           /// Creates a new `Divider` instance with the specified width.
â”‚   â”‚           ///
â”‚   â”‚           /// By default, the divider will use the 'â”€' character as its style.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `width` - The desired total width of the divider in characters.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// A new `Divider` instance.
â”‚   â”‚           pub fn new(width: usize) -> Self {
â”‚   â”‚               Self {
â”‚   â”‚                   width, style: 'â”€'
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the character used to draw the divider.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Divider` instance,
â”‚   â”‚           /// allowing for method chaining.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `style` - The character to use for the divider (e.g., `'='`, `'-'`, `'*'`).
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Divider` instance with the updated style.
â”‚   â”‚           pub fn style(mut self, style: char) -> Self {
â”‚   â”‚               self.style = style;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Prints the `Divider` to the console.
â”‚   â”‚           ///
â”‚   â”‚           /// This method outputs a line of the chosen `style` character, repeated
â”‚   â”‚           /// `width` times, to standard output.
â”‚   â”‚           pub fn print(&self) {
â”‚   â”‚               println!("{}", self.style.to_string().repeat(self.width));
â”‚   â”‚           }
â”‚   â”‚       }
â”‚   â”‚       --- FILE CONTENT END ---
â”‚   â”‚   â”œâ”€â”€ label.rs
â”‚   â”‚       --- FILE CONTENT START ---
â”‚   â”‚       use ansi_term::Colour;
â”‚   â”‚       
â”‚   â”‚       /// Parses a string representation of a color into an `ansi_term::Colour` enum variant.
â”‚   â”‚       ///
â”‚   â”‚       /// This internal helper function supports a predefined set of color names (case-insensitive)
â”‚   â”‚       /// and returns `None` if the name does not match any supported color.
â”‚   â”‚       ///
â”‚   â”‚       /// Supported colors include: "black", "red", "green", "yellow", "blue", "purple", "magenta", "cyan", "white".
â”‚   â”‚       /// "purple" and "magenta" are treated as synonyms.
â”‚   â”‚       ///
â”‚   â”‚       /// # Arguments
â”‚   â”‚       ///
â”‚   â”‚       /// * `name` - A string slice representing the color name.
â”‚   â”‚       ///
â”‚   â”‚       /// # Returns
â”‚   â”‚       ///
â”‚   â”‚       /// An `Option<Colour>` which is `Some(Colour)` if the name is recognized, otherwise `None`.
â”‚   â”‚       pub(crate) fn parse_colour(name: &str) -> Option<Colour> {
â”‚   â”‚           match name.to_lowercase().as_str() {
â”‚   â”‚               "black" => Some(Colour::Black),
â”‚   â”‚               "red" => Some(Colour::Red),
â”‚   â”‚               "green" => Some(Colour::Green),
â”‚   â”‚               "yellow" => Some(Colour::Yellow),
â”‚   â”‚               "blue" => Some(Colour::Blue),
â”‚   â”‚               "purple" | "magenta" => Some(Colour::Purple),
â”‚   â”‚               "cyan" => Some(Colour::Cyan),
â”‚   â”‚               "white" => Some(Colour::White),
â”‚   â”‚               _ => None,
â”‚   â”‚           }
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”‚       /// A customizable text label designed for terminal output, supporting colors, boldness, and predefined styles.
â”‚   â”‚       ///
â”‚   â”‚       /// The `Label` struct allows you to create short, formatted text snippets, often
â”‚   â”‚       /// used for status indicators, categorization, or highlighting. It integrates
â”‚   â”‚       /// with `ansi_term` for rich terminal styling.
â”‚   â”‚       ///
â”‚   â”‚       /// # Examples
â”‚   â”‚       ///
â”‚   â”‚       /// Basic usage:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::Label;
â”‚   â”‚       ///
â”‚   â”‚       /// Label::new("SUCCESS").color("green").bold(true).print();
â”‚   â”‚       /// ```
â”‚   â”‚       ///
â”‚   â”‚       /// Using predefined styles:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::Label;
â”‚   â”‚       ///
â”‚   â”‚       /// Label::new("INFO").style("info").print();
â”‚   â”‚       /// Label::new("ERROR").style("error").print();
â”‚   â”‚       /// ```
â”‚   â”‚       ///
â”‚   â”‚       /// Getting an inline string:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::Label;
â”‚   â”‚       ///
â”‚   â”‚       /// let inline_label = Label::new("STATUS").color("yellow").inline();
â”‚   â”‚       /// println!("Current {}", inline_label);
â”‚   â”‚       /// ```
â”‚   â”‚       pub struct Label {
â”‚   â”‚           text: String,
â”‚   â”‚           color: Option<String>,
â”‚   â”‚           bold: bool,
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”‚       impl Label {
â”‚   â”‚           /// Creates a new `Label` instance with the specified text.
â”‚   â”‚           ///
â”‚   â”‚           /// The label is initially uncolored, not bold, and has no predefined style.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `text` - The string slice that will be displayed within the label.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// A new `Label` instance.
â”‚   â”‚           pub fn new(text: &str) -> Self {
â”‚   â”‚               Self {
â”‚   â”‚                   text: text.to_string(),
â”‚   â”‚                   color: None,
â”‚   â”‚                   bold: false,
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the foreground color of the label.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Label` instance,
â”‚   â”‚           /// allowing for method chaining. The color name should be one of the
â”‚   â”‚           /// supported names (e.g., "red", "blue", "green"). If an unsupported
â”‚   â”‚           /// color name is provided, the color will not be applied.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `color` - A string slice representing the desired color name.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Label` instance with the updated color setting.
â”‚   â”‚           pub fn color(mut self, color: &str) -> Self {
â”‚   â”‚               self.color = Some(color.to_string());
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets whether the label text should be bold.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Label` instance,
â”‚   â”‚           /// allowing for method chaining.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `bold` - A boolean value: `true` for bold text, `false` otherwise.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Label` instance with the updated bold setting.
â”‚   â”‚           pub fn bold(mut self, bold: bool) -> Self {
â”‚   â”‚               self.bold = bold;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Applies a predefined style to the label.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Label` instance,
â”‚   â”‚           /// allowing for method chaining. Predefined styles automatically set
â”‚   â”‚           /// color and/or boldness.
â”‚   â”‚           ///
â”‚   â”‚           /// Supported styles:
â”‚   â”‚           /// - "info": Sets color to blue and bold to true.
â”‚   â”‚           /// - "success": Sets color to green.
â”‚   â”‚           /// - "error": Sets color to red and bold to true.
â”‚   â”‚           ///
â”‚   â”‚           /// If an unsupported style name is provided, no changes are applied.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `style` - A string slice representing the predefined style name.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Label` instance with the applied style.
â”‚   â”‚           pub fn style(self, style: &str) -> Self {
â”‚   â”‚               match style {
â”‚   â”‚                   "info" => self.color("blue").bold(true),
â”‚   â”‚                   "success" => self.color("green"),
â”‚   â”‚                   "error" => self.color("red").bold(true),
â”‚   â”‚                   _ => self,
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Prints the formatted label to the console, enclosed in square brackets.
â”‚   â”‚           ///
â”‚   â”‚           /// The output will include ANSI escape codes for color and boldness if specified.
â”‚   â”‚           /// The label text will be formatted as `[TEXT]`.
â”‚   â”‚           ///
â”‚   â”‚           /// # Examples
â”‚   â”‚           ///
â”‚   â”‚           /// ```
â”‚   â”‚           /// use cliux::components::Label;
â”‚   â”‚           /// Label::new("Done").style("success").print(); // Prints "[Done]" in green
â”‚   â”‚           /// ```
â”‚   â”‚           pub fn print(&self) {
â”‚   â”‚               let mut style = ansi_term::Style::new();
â”‚   â”‚       
â”‚   â”‚               if let Some(ref color_name) = self.color {
â”‚   â”‚                   if let Some(colour) = parse_colour(color_name) {
â”‚   â”‚                       style = style.fg(colour);
â”‚   â”‚                   }
â”‚   â”‚               }
â”‚   â”‚       
â”‚   â”‚               if self.bold {
â”‚   â”‚                   style = style.bold();
â”‚   â”‚               }
â”‚   â”‚       
â”‚   â”‚               println!("{}", style.paint(format!("[{}]", self.text)));
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Returns the formatted label as an `ansi_term::ANSIGenericString`,
â”‚   â”‚           /// suitable for inline use within other `println!` or string operations.
â”‚   â”‚           ///
â”‚   â”‚           /// The returned string will include ANSI escape codes for color and boldness
â”‚   â”‚           /// if specified. The label text will be formatted as `[TEXT]`.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// A `String` containing the formatted label with ANSI escape codes.
â”‚   â”‚           ///
â”‚   â”‚           /// # Examples
â”‚   â”‚           ///
â”‚   â”‚           /// ```
â”‚   â”‚           /// use cliux::components::Label;
â”‚   â”‚           /// let status = Label::new("WARNING").color("yellow").inline();
â”‚   â”‚           /// println!("Operation Status: {}", status);
â”‚   â”‚           /// ```
â”‚   â”‚           pub fn inline(&self) -> String {
â”‚   â”‚               let mut style = ansi_term::Style::new();
â”‚   â”‚       
â”‚   â”‚               if let Some(ref color_name) = self.color {
â”‚   â”‚                   if let Some(colour) = parse_colour(color_name) {
â”‚   â”‚                       style = style.fg(colour);
â”‚   â”‚                   }
â”‚   â”‚               }
â”‚   â”‚       
â”‚   â”‚               if self.bold {
â”‚   â”‚                   style = style.bold();
â”‚   â”‚               }
â”‚   â”‚       
â”‚   â”‚               style.paint(format!("[{}]", self.text)).to_string()
â”‚   â”‚           }
â”‚   â”‚       }
â”‚   â”‚       --- FILE CONTENT END ---
â”‚   â”‚   â”œâ”€â”€ list.rs
â”‚   â”‚       --- FILE CONTENT START ---
â”‚   â”‚       use crate::layout::wrap_text;
â”‚   â”‚       
â”‚   â”‚       /// A component for displaying lists of items in the terminal.
â”‚   â”‚       ///
â”‚   â”‚       /// The `List` struct allows you to present collections of text items either
â”‚   â”‚       /// as bullet points or numbered lists. It supports optional text wrapping
â”‚   â”‚       /// for long list items.
â”‚   â”‚       ///
â”‚   â”‚       /// # Examples
â”‚   â”‚       ///
â”‚   â”‚       /// Basic bullet list:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::List;
â”‚   â”‚       ///
â”‚   â”‚       /// List::new(vec!["Item One", "Item Two", "Item Three"]).print();
â”‚   â”‚       /// ```
â”‚   â”‚       ///
â”‚   â”‚       /// Numbered list:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::List;
â”‚   â”‚       ///
â”‚   â”‚       /// List::new(vec!["First Step", "Second Step", "Third Step"])
â”‚   â”‚       ///     .numbered()
â”‚   â”‚       ///     .print();
â”‚   â”‚       /// ```
â”‚   â”‚       ///
â”‚   â”‚       /// List with custom bullet and wrapped text:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::List;
â”‚   â”‚       ///
â”‚   â”‚       /// let long_item = "This is a very long list item that needs to be wrapped across multiple lines.";
â”‚   â”‚       /// List::new(vec!["Short item", long_item, "Another item"])
â”‚   â”‚       ///     .bullet("âž¢")
â”‚   â”‚       ///     .width(40)
â”‚   â”‚       ///     .print();
â”‚   â”‚       /// ```
â”‚   â”‚       pub struct List {
â”‚   â”‚           items: Vec<String>,
â”‚   â”‚           bullet: Option<String>,
â”‚   â”‚           width: Option<usize>,
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”‚       impl List {
â”‚   â”‚           /// Creates a new `List` instance with the given items.
â”‚   â”‚           ///
â”‚   â”‚           /// By default, the list will use a bullet point (`â€¢`) for each item
â”‚   â”‚           /// and will not be numbered. Items will not be wrapped unless a `width`
â”‚   â”‚           /// is explicitly set.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `items` - A `Vec` of string slices representing the items in the list.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// A new `List` instance.
â”‚   â”‚           pub fn new(items: Vec<&str>) -> Self {
â”‚   â”‚               Self {
â”‚   â”‚                   items: items.into_iter().map(|s| s.to_string()).collect(),
â”‚   â”‚                   bullet: Some("â€¢".to_string()),
â”‚   â”‚                   width: None,
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets a custom bullet symbol for the list.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `List` instance,
â”‚   â”‚           /// allowing for method chaining. Calling this will disable numbering.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `symbol` - A string slice representing the custom bullet symbol (e.g., `"-"`, `"*"`).
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `List` instance with the updated bullet symbol.
â”‚   â”‚           pub fn bullet(mut self, symbol: &str) -> Self {
â”‚   â”‚               self.bullet = Some(symbol.to_string());
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Configures the list to be numbered (e.g., "1. ", "2. ").
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `List` instance,
â”‚   â”‚           /// allowing for method chaining. Calling this will disable custom bullets.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `List` instance configured for numbering.
â”‚   â”‚           pub fn numbered(mut self) -> Self {
â”‚   â”‚               self.bullet = None;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the maximum width for each list item, enabling text wrapping.
â”‚   â”‚           ///
â”‚   â”‚           /// If an item's content exceeds this width, it will be wrapped onto
â”‚   â”‚           /// subsequent lines, indented to align with the start of the item's text.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `List` instance,
â”‚   â”‚           /// allowing for method chaining.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `width` - The maximum desired width for each wrapped list item in characters.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `List` instance with the updated width setting.
â”‚   â”‚           pub fn width(mut self, width: usize) -> Self {
â”‚   â”‚               self.width = Some(width);
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Prints the formatted list to the console.
â”‚   â”‚           ///
â”‚   â”‚           /// Each item is printed on its own line, prefixed by either a bullet
â”‚   â”‚           /// or a number, and potentially wrapped if a width is set.
â”‚   â”‚           pub fn print(&self) {
â”‚   â”‚               for (i, item) in self.items.iter().enumerate() {
â”‚   â”‚                   let prefix = match &self.bullet {
â”‚   â”‚                       Some(symbol) => format!("{} ", symbol),
â”‚   â”‚                       None => format!("{}. ", i + 1),
â”‚   â”‚                   };
â”‚   â”‚       
â”‚   â”‚                   let lines = if let Some(w) = self.width {
â”‚   â”‚                       // Subtract prefix length from total width for wrapping calculation
â”‚   â”‚                       wrap_text(item, w.saturating_sub(prefix.len()))
â”‚   â”‚                   } else {
â”‚   â”‚                       vec![item.clone()]
â”‚   â”‚                   };
â”‚   â”‚       
â”‚   â”‚                   for (j, line) in lines.iter().enumerate() {
â”‚   â”‚                       if j == 0 {
â”‚   â”‚                           // First line gets the prefix
â”‚   â”‚                           println!("{}{}", prefix, line);
â”‚   â”‚                       } else {
â”‚   â”‚                           // Subsequent lines are indented by the prefix length
â”‚   â”‚                           println!("{}{}", " ".repeat(prefix.len()), line);
â”‚   â”‚                       }
â”‚   â”‚                   }
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       }
â”‚   â”‚       --- FILE CONTENT END ---
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚       --- FILE CONTENT START ---
â”‚   â”‚       pub mod boxed;
â”‚   â”‚       pub mod divider;
â”‚   â”‚       pub mod label;
â”‚   â”‚       pub mod list;
â”‚   â”‚       pub mod note;
â”‚   â”‚       pub mod section;
â”‚   â”‚       pub mod table;
â”‚   â”‚       pub mod tag;
â”‚   â”‚       
â”‚   â”‚       pub use boxed::Boxed;
â”‚   â”‚       pub use divider::Divider;
â”‚   â”‚       pub use label::Label;
â”‚   â”‚       pub use list::List;
â”‚   â”‚       pub use section::Section;
â”‚   â”‚       pub use table::Table;
â”‚   â”‚       pub use tag::Tag;
â”‚   â”‚       pub use note::Note;
â”‚   â”‚       --- FILE CONTENT END ---
â”‚   â”‚   â”œâ”€â”€ note.rs
â”‚   â”‚       --- FILE CONTENT START ---
â”‚   â”‚       use crate::layout::pad;
â”‚   â”‚       use ansi_term::{Colour, Style};
â”‚   â”‚       
â”‚   â”‚       /// A styled callout block for warnings, tips, and info messages.
â”‚   â”‚       ///
â”‚   â”‚       /// The `Note` struct provides a way to display important messages
â”‚   â”‚       /// in a visually distinct box in the terminal. It supports various
â”‚   â”‚       /// kinds (info, warning, tip), custom icons, colors, boldness,
â”‚   â”‚       /// and different border styles.
â”‚   â”‚       ///
â”‚   â”‚       /// # Examples
â”‚   â”‚       ///
â”‚   â”‚       /// A basic information note:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::Note;
â”‚   â”‚       ///
â”‚   â”‚       /// Note::new("This is an important piece of information.")
â”‚   â”‚       ///     .kind("info")
â”‚   â”‚       ///     .print();
â”‚   â”‚       /// ```
â”‚   â”‚       ///
â”‚   â”‚       /// A warning note with a custom width and square borders:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::Note;
â”‚   â”‚       ///
â”‚   â”‚       /// Note::new("Be cautious when proceeding with this action.")
â”‚   â”‚       ///     .kind("warning")
â”‚   â”‚       ///     .width(60)
â”‚   â”‚       ///     .style("square")
â”‚   â”‚       ///     .print();
â”‚   â”‚       /// ```
â”‚   â”‚       ///
â”‚   â”‚       /// A tip with a custom icon and color:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::Note;
â”‚   â”‚       ///
â”‚   â”‚       /// Note::new("Remember to save your work frequently!")
â”‚   â”‚       ///     .icon("âœ¨")
â”‚   â”‚       ///     .color("magenta")
â”‚   â”‚       ///     .bold(true)
â”‚   â”‚       ///     .print();
â”‚   â”‚       /// ```
â”‚   â”‚       pub struct Note {
â”‚   â”‚           text: String,
â”‚   â”‚           icon: Option<String>,
â”‚   â”‚           color: Option<String>,
â”‚   â”‚           bold: bool,
â”‚   â”‚           style: String, // "rounded", "square", "+"
â”‚   â”‚           width: usize,
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”‚       impl Note {
â”‚   â”‚           /// Creates a new `Note` instance with the given text.
â”‚   â”‚           ///
â”‚   â”‚           /// By default, the note will have "rounded" borders, a width of 50 characters,
â”‚   â”‚           /// no specific icon, color, or boldness.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `text` - The main content string for the note.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// A new `Note` instance.
â”‚   â”‚           pub fn new(text: &str) -> Self {
â”‚   â”‚               Self {
â”‚   â”‚                   text: text.to_string(),
â”‚   â”‚                   icon: None,
â”‚   â”‚                   color: None,
â”‚   â”‚                   bold: false,
â”‚   â”‚                   style: "rounded".to_string(),
â”‚   â”‚                   width: 50,
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Applies a predefined "kind" style to the note.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Note` instance,
â”‚   â”‚           /// allowing for method chaining. It sets a default icon, color,
â”‚   â”‚           /// and boldness based on the `kind`.
â”‚   â”‚           ///
â”‚   â”‚           /// Supported `kind`s:
â”‚   â”‚           /// - `"info"`: Sets icon to "â„¹ï¸", color to blue.
â”‚   â”‚           /// - `"warning"`: Sets icon to "âš ï¸", color to yellow, and text to bold.
â”‚   â”‚           /// - `"tip"`: Sets icon to "ðŸ’¡", color to green.
â”‚   â”‚           ///
â”‚   â”‚           /// If an unknown `kind` is provided, the note remains unchanged.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `kind` - A string slice representing the predefined style kind.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Note` instance with the applied kind style.
â”‚   â”‚           pub fn kind(mut self, kind: &str) -> Self {
â”‚   â”‚               match kind {
â”‚   â”‚                   "info" => {
â”‚   â”‚                       self.icon = Some("â„¹ï¸".to_string());
â”‚   â”‚                       self.color = Some("blue".to_string());
â”‚   â”‚                   }
â”‚   â”‚                   "warning" => {
â”‚   â”‚                       self.icon = Some("âš ï¸".to_string());
â”‚   â”‚                       self.color = Some("yellow".to_string());
â”‚   â”‚                       self.bold = true;
â”‚   â”‚                   }
â”‚   â”‚                   "tip" => {
â”‚   â”‚                       self.icon = Some("ðŸ’¡".to_string());
â”‚   â”‚                       self.color = Some("green".to_string());
â”‚   â”‚                   }
â”‚   â”‚                   _ => {}
â”‚   â”‚               }
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets a custom icon for the note.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Note` instance,
â”‚   â”‚           /// allowing for method chaining. This will override any icon set by `kind()`.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `icon` - A string slice representing the custom icon (e.g., an emoji like "âœ¨").
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Note` instance with the updated icon.
â”‚   â”‚           pub fn icon(mut self, icon: &str) -> Self {
â”‚   â”‚               self.icon = Some(icon.to_string());
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the foreground color of the note's text and icon.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Note` instance,
â”‚   â”‚           /// allowing for method chaining. Supported colors include "red", "green",
â”‚   â”‚           /// "yellow", "blue", "magenta" (or "purple"), "cyan", and "white".
â”‚   â”‚           /// Color names are case-insensitive.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `color` - A string slice representing the desired color name.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Note` instance with the updated color.
â”‚   â”‚           pub fn color(mut self, color: &str) -> Self {
â”‚   â”‚               self.color = Some(color.to_string());
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets whether the note's text and icon should be bold.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Note` instance,
â”‚   â”‚           /// allowing for method chaining.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `bold` - A boolean indicating whether the text should be bold (`true`) or not (`false`).
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Note` instance with the updated bold setting.
â”‚   â”‚           pub fn bold(mut self, bold: bool) -> Self {
â”‚   â”‚               self.bold = bold;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the border style for the note.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Note` instance,
â”‚   â”‚           /// allowing for method chaining.
â”‚   â”‚           ///
â”‚   â”‚           /// Supported styles:
â”‚   â”‚           /// - `"rounded"` (default): Uses `â•­â•®â•°â•¯â”€â”‚` characters.
â”‚   â”‚           /// - `"square"`: Uses `â”Œâ”â””â”˜â”€â”‚` characters.
â”‚   â”‚           /// - `"+"`: Uses `++++--||` characters for a simpler ASCII look.
â”‚   â”‚           ///
â”‚   â”‚           /// If an unknown style is provided, it defaults to "square" borders.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `style` - A string slice representing the desired border style.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Note` instance with the updated border style.
â”‚   â”‚           pub fn style(mut self, style: &str) -> Self {
â”‚   â”‚               self.style = style.to_string();
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the total width of the note box.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Note` instance,
â”‚   â”‚           /// allowing for method chaining. The content will be padded to fit
â”‚   â”‚           /// within this width.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `width` - The desired total width of the note box in characters.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Note` instance with the updated width.
â”‚   â”‚           pub fn width(mut self, width: usize) -> Self {
â”‚   â”‚               self.width = width;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Prints the formatted note to the console.
â”‚   â”‚           ///
â”‚   â”‚           /// This method constructs the note with its borders, icon, styled text,
â”‚   â”‚           /// and padding, then prints it to standard output.
â”‚   â”‚           pub fn print(&self) {
â”‚   â”‚               let (tl, tr, bl, br, _, v) = get_border(&self.style);
â”‚   â”‚       
â”‚   â”‚               // Combine icon and text for content
â”‚   â”‚               let content = match &self.icon {
â”‚   â”‚                   Some(icon) => format!("{} {}", icon, self.text),
â”‚   â”‚                   None => self.text.clone(),
â”‚   â”‚               };
â”‚   â”‚       
â”‚   â”‚               // Build ANSI style for text and icon
â”‚   â”‚               let mut style = Style::new();
â”‚   â”‚               if let Some(ref color_name) = self.color {
â”‚   â”‚                   style = match color_name.as_str() {
â”‚   â”‚                       "red" => style.fg(Colour::Red),
â”‚   â”‚                       "green" => style.fg(Colour::Green),
â”‚   â”‚                       "yellow" => style.fg(Colour::Yellow),
â”‚   â”‚                       "blue" => style.fg(Colour::Blue),
â”‚   â”‚                       "purple" | "magenta" => style.fg(Colour::Purple),
â”‚   â”‚                       "cyan" => style.fg(Colour::Cyan),
â”‚   â”‚                       "white" => style.fg(Colour::White),
â”‚   â”‚                       _ => style, // Fallback for unsupported colors
â”‚   â”‚                   };
â”‚   â”‚               }
â”‚   â”‚               if self.bold {
â”‚   â”‚                   style = style.bold();
â”‚   â”‚               }
â”‚   â”‚       
â”‚   â”‚               // Apply padding and style to the content
â”‚   â”‚               // Subtract 2 for the vertical borders and two spaces for padding inside
â”‚   â”‚               let content_width = self.width.saturating_sub(4);
â”‚   â”‚               let padded_content = pad(&content, content_width);
â”‚   â”‚               let styled_content = style.paint(padded_content);
â”‚   â”‚       
â”‚   â”‚               // Print the note box
â”‚   â”‚               println!(
â”‚   â”‚                   "{}{:â”€<width$}{}",
â”‚   â”‚                   tl,
â”‚   â”‚                   "",
â”‚   â”‚                   tr,
â”‚   â”‚                   width = self.width.saturating_sub(2)
â”‚   â”‚               ); // Top border
â”‚   â”‚               println!("{} {} {}", v, styled_content, v); // Content line
â”‚   â”‚               println!(
â”‚   â”‚                   "{}{:â”€<width$}{}",
â”‚   â”‚                   bl,
â”‚   â”‚                   "",
â”‚   â”‚                   br,
â”‚   â”‚                   width = self.width.saturating_sub(2)
â”‚   â”‚               ); // Bottom border
â”‚   â”‚           }
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”‚       /// Internal helper function to get border characters based on the specified style.
â”‚   â”‚       ///
â”‚   â”‚       /// # Arguments
â”‚   â”‚       ///
â”‚   â”‚       /// * `style` - A string slice indicating the desired border style ("rounded", "square", "+").
â”‚   â”‚       ///
â”‚   â”‚       /// # Returns
â”‚   â”‚       ///
â”‚   â”‚       /// A tuple of string slices representing (top-left, top-right, bottom-left, bottom-right, horizontal, vertical)
â”‚   â”‚       /// border characters. Defaults to "square" style if an unknown style is provided.
â”‚   â”‚       fn get_border(style: &str) -> (&str, &str, &str, &str, &str, &str) {
â”‚   â”‚           match style {
â”‚   â”‚               "rounded" => ("â•­", "â•®", "â•°", "â•¯", "â”€", "â”‚"),
â”‚   â”‚               "square" => ("â”Œ", "â”", "â””", "â”˜", "â”€", "â”‚"),
â”‚   â”‚               "+" => ("+", "+", "+", "+", "-", "|"),
â”‚   â”‚               _ => ("â”Œ", "â”", "â””", "â”˜", "â”€", "â”‚"), // Default to square if style is unrecognized
â”‚   â”‚           }
â”‚   â”‚       }
â”‚   â”‚       --- FILE CONTENT END ---
â”‚   â”‚   â”œâ”€â”€ section.rs
â”‚   â”‚       --- FILE CONTENT START ---
â”‚   â”‚       use crate::layout::{pad, wrap_text};
â”‚   â”‚       
â”‚   â”‚       /// A titled block of content, often used for organizing information
â”‚   â”‚       /// with a preceding title and a divider.
â”‚   â”‚       ///
â”‚   â”‚       /// The `Section` struct provides a way to present blocks of text with a clear
â”‚   â”‚       /// title and an optional horizontal separator. It supports intelligent text
â”‚   â”‚       /// wrapping to fit content within a specified width.
â”‚   â”‚       ///
â”‚   â”‚       /// # Examples
â”‚   â”‚       ///
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::Section;
â”‚   â”‚       ///
â”‚   â”‚       /// Section::new("Introduction")
â”‚   â”‚       ///     .content("This is the beginning of a new section. It can have some introductory text.")
â”‚   â”‚       ///     .width(60)
â”‚   â”‚       ///     .print();
â”‚   â”‚       ///
â”‚   â”‚       /// Section::new("Long Text Section")
â”‚   â”‚       ///     .content("This is a very long sentence that needs to be wrapped intelligently across multiple lines so that it fits neatly within the terminal output and doesn't overflow its boundaries.")
â”‚   â”‚       ///     .width(40)
â”‚   â”‚       ///     .wrap(true)
â”‚   â”‚       ///     .style('=')
â”‚   â”‚       ///     .print();
â”‚   â”‚       /// ```
â”‚   â”‚       pub struct Section {
â”‚   â”‚           title: String,
â”‚   â”‚           content: String,
â”‚   â”‚           width: usize,
â”‚   â”‚           style: char,
â”‚   â”‚           wrap: bool,
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”‚       impl Section {
â”‚   â”‚           /// Creates a new `Section` instance with the given title.
â”‚   â”‚           ///
â”‚   â”‚           /// By default, the section will have no content, a width of 50 characters,
â”‚   â”‚           /// a default divider style of `'â”€'`, and text wrapping disabled.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `title` - The title of the section.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// A new `Section` instance.
â”‚   â”‚           pub fn new(title: &str) -> Self {
â”‚   â”‚               Self {
â”‚   â”‚                   title: title.to_string(),
â”‚   â”‚                   content: String::new(),
â”‚   â”‚                   width: 50,
â”‚   â”‚                   style: 'â”€',
â”‚   â”‚                   wrap: false,
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the main content of the section.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Section` instance,
â”‚   â”‚           /// allowing for method chaining. Newline characters (`\n`) in the content
â”‚   â”‚           /// will create new paragraphs or line breaks within the section.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `text` - The string slice containing the content for the section.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Section` instance with the updated content.
â”‚   â”‚           pub fn content(mut self, text: &str) -> Self {
â”‚   â”‚               self.content = text.to_string();
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the total width of the section's content and divider.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Section` instance,
â”‚   â”‚           /// allowing for method chaining. The content will be padded or wrapped
â”‚   â”‚           /// to fit this width.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `width` - The desired total width of the section in characters.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Section` instance with the updated width.
â”‚   â”‚           pub fn width(mut self, width: usize) -> Self {
â”‚   â”‚               self.width = width;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the character used for the horizontal divider within the section.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Section` instance,
â”‚   â”‚           /// allowing for method chaining.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `style` - The character to use for the divider (e.g., `'='`, `'-'`, `'*'`).
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Section` instance with the updated style.
â”‚   â”‚           pub fn style(mut self, style: char) -> Self {
â”‚   â”‚               self.style = style;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Enables or disables intelligent text wrapping for the content within the section.
â”‚   â”‚           ///
â”‚   â”‚           /// If `true`, long lines of content will be wrapped to fit the specified `width`
â”‚   â”‚           /// at word boundaries. If `false` (default), lines will only break at explicit
â”‚   â”‚           /// newline characters (`\n`).
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Section` instance,
â”‚   â”‚           /// allowing for method chaining.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `wrap` - A boolean indicating whether to enable (`true`) or disable (`false`) text wrapping.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Section` instance with the updated wrap setting.
â”‚   â”‚           pub fn wrap(mut self, wrap: bool) -> Self {
â”‚   â”‚               self.wrap = wrap;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Prints the `Section` to the console.
â”‚   â”‚           ///
â”‚   â”‚           /// This method renders the section, including its title, a horizontal
â”‚   â”‚           /// divider, and its content (with optional wrapping and padding),
â”‚   â”‚           /// to standard output.
â”‚   â”‚           pub fn print(&self) {
â”‚   â”‚               println!("{}:", self.title);
â”‚   â”‚               println!("{}", self.style.to_string().repeat(self.width));
â”‚   â”‚               let lines = if self.wrap {
â”‚   â”‚                   wrap_text(&self.content, self.width)
â”‚   â”‚               } else {
â”‚   â”‚                   self.content.lines().map(|l| l.to_string()).collect()
â”‚   â”‚               };
â”‚   â”‚       
â”‚   â”‚               for line in lines {
â”‚   â”‚                   println!("{}", pad(&line, self.width));
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       }
â”‚   â”‚       --- FILE CONTENT END ---
â”‚   â”‚   â”œâ”€â”€ table.rs
â”‚   â”‚       --- FILE CONTENT START ---
â”‚   â”‚       use crate::layout::pad;
â”‚   â”‚       
â”‚   â”‚       /// A component for displaying tabular data in the terminal.
â”‚   â”‚       ///
â”‚   â”‚       /// The `Table` struct allows you to present data in a structured,
â”‚   â”‚       /// grid-like format with optional headers and borders. It supports
â”‚   â”‚       /// defining column widths and automatically handles text padding
â”‚   â”‚       /// within cells.
â”‚   â”‚       ///
â”‚   â”‚       /// # Examples
â”‚   â”‚       ///
â”‚   â”‚       /// Basic table with headers and borders:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::Table;
â”‚   â”‚       ///
â”‚   â”‚       /// Table::new()
â”‚   â”‚       ///     .headers(&["Name", "Age", "City"])
â”‚   â”‚       ///     .row(&["Alice", "30", "New York"])
â”‚   â”‚       ///     .row(&["Bob", "24", "Los Angeles"])
â”‚   â”‚       ///     .print();
â”‚   â”‚       /// ```
â”‚   â”‚       ///
â”‚   â”‚       /// Table without borders and custom column widths:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::Table;
â”‚   â”‚       ///
â”‚   â”‚       /// Table::new()
â”‚   â”‚       ///     .headers(&["Product", "Price", "Availability"])
â”‚   â”‚       ///     .row(&["Laptop", "$1200", "In Stock"])
â”‚   â”‚       ///     .row(&["Mouse", "$25", "Low"])
â”‚   â”‚       ///     .bordered(false)
â”‚   â”‚       ///     .widths(&[15, 10, 15])
â”‚   â”‚       ///     .print();
â”‚   â”‚       /// ```
â”‚   â”‚       ///
â”‚   â”‚       /// Table with multi-line content (requires `widths` to be set to enable wrapping within `print`):
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::Table;
â”‚   â”‚       ///
â”‚   â”‚       /// Table::new()
â”‚   â”‚       ///     .headers(&["Task", "Description"])
â”‚   â”‚       ///     .row(&[
â”‚   â”‚       ///         "Prepare report",
â”‚   â”‚       ///         "Gather all data, analyze, and draft the executive summary by end of day."
â”‚   â”‚       ///     ])
â”‚   â”‚       ///     .row(&[
â”‚   â”‚       ///         "Review code",
â”‚   â”‚       ///         "Check for bugs, performance issues, and adherence to coding standards."
â”‚   â”‚       ///     ])
â”‚   â”‚       ///     .widths(&[20, 50])
â”‚   â”‚       ///     .print();
â”‚   â”‚       /// ```
â”‚   â”‚       pub struct Table {
â”‚   â”‚           headers: Option<Vec<String>>,
â”‚   â”‚           rows: Vec<Vec<String>>,
â”‚   â”‚           bordered: bool,
â”‚   â”‚           widths: Option<Vec<usize>>,
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”‚       impl Table {
â”‚   â”‚           /// Creates a new, empty `Table` instance.
â”‚   â”‚           ///
â”‚   â”‚           /// By default, the table will have no headers or rows,
â”‚   â”‚           /// will be bordered, and will auto-calculate column widths
â”‚   â”‚           /// based on content if not explicitly set.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// A new `Table` instance.
â”‚   â”‚           pub fn new() -> Self {
â”‚   â”‚               Self {
â”‚   â”‚                   headers: None,
â”‚   â”‚                   rows: Vec::new(),
â”‚   â”‚                   bordered: true,
â”‚   â”‚                   widths: None,
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the headers for the table.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Table` instance,
â”‚   â”‚           /// allowing for method chaining. The number of headers defines the
â”‚   â”‚           /// number of columns in the table.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `headers` - A slice of string slices, where each slice is a column header.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Table` instance with the updated headers.
â”‚   â”‚           pub fn headers(mut self, headers: &[&str]) -> Self {
â”‚   â”‚               self.headers = Some(headers.iter().map(|s| s.to_string()).collect());
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Adds a new row to the table.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Table` instance,
â”‚   â”‚           /// allowing for method chaining. Each `row` call adds one row.
â”‚   â”‚           /// It's expected that the number of cells in each row matches
â”‚   â”‚           /// the number of headers (or the first row's length if no headers).
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `row` - A slice of string slices, where each slice is a cell in the row.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Table` instance with the new row added.
â”‚   â”‚           pub fn row(mut self, row: &[&str]) -> Self {
â”‚   â”‚               self.rows.push(row.iter().map(|s| s.to_string()).collect());
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets whether the table should be drawn with borders.
â”‚   â”‚           ///
â”‚   â”‚           /// By default, tables are bordered. Setting this to `false` will
â”‚   â”‚           /// remove the surrounding and internal borders.
â”‚   â”‚           /// This method consumes `self` and returns a new `Table` instance,
â”‚   â”‚           /// allowing for method chaining.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `bordered` - A boolean indicating whether to draw borders (`true`) or not (`false`).
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Table` instance with the updated border setting.
â”‚   â”‚           pub fn bordered(mut self, bordered: bool) -> Self {
â”‚   â”‚               self.bordered = bordered;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets custom widths for each column.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Table` instance,
â”‚   â”‚           /// allowing for method chaining. The number of elements in `widths`
â”‚   â”‚           /// should match the number of columns in the table. If content
â”‚   â”‚           /// exceeds a column's width, it will be wrapped.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `widths` - A slice of `usize` values, where each value is the desired
â”‚   â”‚           ///   width for the corresponding column.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Table` instance with the custom column widths set.
â”‚   â”‚           pub fn widths(mut self, widths: &[usize]) -> Self {
â”‚   â”‚               self.widths = Some(widths.to_vec());
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Prints the formatted table to the console.
â”‚   â”‚           ///
â”‚   â”‚           /// This method constructs the table based on the configured headers,
â”‚   â”‚           /// rows, border setting, and column widths, then prints it to
â”‚   â”‚           /// standard output. Content will be padded or wrapped according to `widths`.
â”‚   â”‚           pub fn print(&self) {
â”‚   â”‚               let col_count = self
â”‚   â”‚                   .headers
â”‚   â”‚                   .as_ref()
â”‚   â”‚                   .map_or_else(|| self.rows.first().map_or(0, |r| r.len()), |h| h.len());
â”‚   â”‚       
â”‚   â”‚               // Auto-calculate column widths
â”‚   â”‚               let widths = self.widths.clone().unwrap_or_else(|| {
â”‚   â”‚                   let mut max_widths = vec![0; col_count];
â”‚   â”‚                   if let Some(ref headers) = self.headers {
â”‚   â”‚                       for (i, h) in headers.iter().enumerate() {
â”‚   â”‚                           max_widths[i] = max_widths[i].max(h.len());
â”‚   â”‚                       }
â”‚   â”‚                   }
â”‚   â”‚                   for row in &self.rows {
â”‚   â”‚                       for (i, cell) in row.iter().enumerate() {
â”‚   â”‚                           max_widths[i] = max_widths[i].max(cell.len());
â”‚   â”‚                       }
â”‚   â”‚                   }
â”‚   â”‚                   max_widths.iter().map(|w| w + 2).collect() // add padding
â”‚   â”‚               });
â”‚   â”‚       
â”‚   â”‚               let draw_border = || {
â”‚   â”‚                   if self.bordered {
â”‚   â”‚                       print!("+");
â”‚   â”‚                       for w in &widths {
â”‚   â”‚                           print!("{:-<1$}+", "", *w);
â”‚   â”‚                       }
â”‚   â”‚                       println!();
â”‚   â”‚                   }
â”‚   â”‚               };
â”‚   â”‚       
â”‚   â”‚               let draw_row = |row: &[String]| {
â”‚   â”‚                   if self.bordered {
â”‚   â”‚                       print!("|");
â”‚   â”‚                   }
â”‚   â”‚                   for (i, cell) in row.iter().enumerate() {
â”‚   â”‚                       let padded = pad(cell, widths[i] - 2);
â”‚   â”‚                       print!(" {} ", padded);
â”‚   â”‚                       if self.bordered {
â”‚   â”‚                           print!("|");
â”‚   â”‚                       } else if i < row.len() - 1 {
â”‚   â”‚                           print!(" ");
â”‚   â”‚                       }
â”‚   â”‚                   }
â”‚   â”‚                   println!();
â”‚   â”‚               };
â”‚   â”‚       
â”‚   â”‚               if let Some(ref headers) = self.headers {
â”‚   â”‚                   draw_border();
â”‚   â”‚                   draw_row(headers);
â”‚   â”‚                   draw_border();
â”‚   â”‚               }
â”‚   â”‚       
â”‚   â”‚               for row in &self.rows {
â”‚   â”‚                   draw_row(row);
â”‚   â”‚               }
â”‚   â”‚       
â”‚   â”‚               if self.bordered {
â”‚   â”‚                   draw_border();
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       }
â”‚   â”‚       --- FILE CONTENT END ---
â”‚   â”‚   â””â”€â”€ tag.rs
â”‚   â”‚       --- FILE CONTENT START ---
â”‚   â”‚       /// A component for displaying styled text tags in the terminal.
â”‚   â”‚       ///
â”‚   â”‚       /// The `Tag` struct allows you to create short, enclosed text snippets
â”‚   â”‚       /// with customizable wrappers (e.g., square brackets, parentheses, curly braces),
â”‚   â”‚       /// color, and boldness. Tags are useful for categorization, status indicators,
â”‚   â”‚       /// or drawing attention to specific keywords.
â”‚   â”‚       ///
â”‚   â”‚       /// # Examples
â”‚   â”‚       ///
â”‚   â”‚       /// Basic usage with default square brackets:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::Tag;
â”‚   â”‚       ///
â”‚   â”‚       /// Tag::new("ALPHA").color("red").bold(true).print();
â”‚   â”‚       /// ```
â”‚   â”‚       ///
â”‚   â”‚       /// Using rounded wrappers:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::Tag;
â”‚   â”‚       ///
â”‚   â”‚       /// Tag::new("BETA").rounded().color("blue").print();
â”‚   â”‚       /// ```
â”‚   â”‚       ///
â”‚   â”‚       /// Using curly wrappers:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::Tag;
â”‚   â”‚       ///
â”‚   â”‚       /// Tag::new("STABLE").curly().color("green").print();
â”‚   â”‚       /// ```
â”‚   â”‚       ///
â”‚   â”‚       /// Getting an inline string tag:
â”‚   â”‚       /// ```
â”‚   â”‚       /// use cliux::components::Tag;
â”‚   â”‚       ///
â”‚   â”‚       /// let feature_tag = Tag::new("NEW").color("cyan").inline();
â”‚   â”‚       /// println!("{} This is a new feature!", feature_tag);
â”‚   â”‚       /// ```
â”‚   â”‚       pub struct Tag {
â”‚   â”‚           text: String,
â”‚   â”‚           wrapper: (String, String), // e.g. ("(", ")")
â”‚   â”‚           color: Option<String>,
â”‚   â”‚           bold: bool,
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”‚       impl Tag {
â”‚   â”‚           /// Creates a new `Tag` instance with the specified text.
â”‚   â”‚           ///
â”‚   â”‚           /// By default, the tag will be enclosed in square brackets `[]`,
â”‚   â”‚           /// will have no specific color, and will not be bold.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `text` - The string slice to be displayed as the tag's text.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// A new `Tag` instance.
â”‚   â”‚           pub fn new(text: &str) -> Self {
â”‚   â”‚               Self {
â”‚   â”‚                   text: text.to_string(),
â”‚   â”‚                   wrapper: ("[".to_string(), "]".to_string()),
â”‚   â”‚                   color: None,
â”‚   â”‚                   bold: false,
â”‚   â”‚               }
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the tag's wrappers to rounded parentheses `()`.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Tag` instance,
â”‚   â”‚           /// allowing for method chaining.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Tag` instance with rounded wrappers.
â”‚   â”‚           pub fn rounded(mut self) -> Self {
â”‚   â”‚               self.wrapper = ("(".to_string(), ")".to_string());
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the tag's wrappers to curly braces `{}`.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Tag` instance,
â”‚   â”‚           /// allowing for method chaining.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Tag` instance with curly braces wrappers.
â”‚   â”‚           pub fn curly(mut self) -> Self {
â”‚   â”‚               self.wrapper = ("{".to_string(), "}".to_string());
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets the color of the tag's text.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Tag` instance,
â”‚   â”‚           /// allowing for method chaining. Supported colors are parsed by
â”‚   â”‚           /// `super::label::parse_colour`. If an unsupported color name
â”‚   â”‚           /// is provided, the color will not be applied.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `color` - A string slice representing the desired color name
â”‚   â”‚           ///   (e.g., "red", "blue", "green").
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Tag` instance with the updated color.
â”‚   â”‚           pub fn color(mut self, color: &str) -> Self {
â”‚   â”‚               self.color = Some(color.to_string());
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Sets whether the tag's text should be bold.
â”‚   â”‚           ///
â”‚   â”‚           /// This method consumes `self` and returns a new `Tag` instance,
â”‚   â”‚           /// allowing for method chaining.
â”‚   â”‚           ///
â”‚   â”‚           /// # Arguments
â”‚   â”‚           ///
â”‚   â”‚           /// * `bold` - A boolean indicating whether the text should be bold (`true`) or not (`false`).
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// The `Tag` instance with the updated bold setting.
â”‚   â”‚           pub fn bold(mut self, bold: bool) -> Self {
â”‚   â”‚               self.bold = bold;
â”‚   â”‚               self
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Returns the styled tag as a `String`, including its wrappers.
â”‚   â”‚           ///
â”‚   â”‚           /// This method formats the tag's text with the applied color and bold settings,
â”‚   â”‚           /// enclosed within its chosen wrappers, and returns it as a `String`.
â”‚   â”‚           /// This is useful for embedding the tag within other `println!` statements or strings.
â”‚   â”‚           ///
â”‚   â”‚           /// # Returns
â”‚   â”‚           ///
â”‚   â”‚           /// A `String` containing the styled tag with ANSI escape codes.
â”‚   â”‚           pub fn inline(&self) -> String {
â”‚   â”‚               use ansi_term::Style;
â”‚   â”‚       
â”‚   â”‚               let mut style = Style::new();
â”‚   â”‚               if let Some(ref color) = self.color {
â”‚   â”‚                   if let Some(colour) = super::label::parse_colour(color) {
â”‚   â”‚                       style = style.fg(colour);
â”‚   â”‚                   }
â”‚   â”‚               }
â”‚   â”‚               if self.bold {
â”‚   â”‚                   style = style.bold();
â”‚   â”‚               }
â”‚   â”‚       
â”‚   â”‚               style
â”‚   â”‚                   .paint(format!("{}{}{}", self.wrapper.0, self.text, self.wrapper.1))
â”‚   â”‚                   .to_string()
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚           /// Prints the styled tag to the console, including its wrappers.
â”‚   â”‚           ///
â”‚   â”‚           /// This method formats the tag's text with the applied color and bold settings
â”‚   â”‚           /// and prints it to standard output, e.g., `[TAG TEXT]`.
â”‚   â”‚           pub fn print(&self) {
â”‚   â”‚               println!("{}", self.inline());
â”‚   â”‚           }
â”‚   â”‚       }
â”‚   â”‚       --- FILE CONTENT END ---
â”‚   â”œâ”€â”€ layout.rs
â”‚       --- FILE CONTENT START ---
â”‚       use unicode_segmentation::UnicodeSegmentation;
â”‚       use unicode_width::UnicodeWidthStr;
â”‚       
â”‚       /// Pads the given `text` with spaces on the right to reach the specified `width`.
â”‚       ///
â”‚       /// This function is Unicode-aware, correctly handling multi-byte characters like emojis
â”‚       /// by considering their display width rather than byte length.
â”‚       ///
â”‚       /// # Arguments
â”‚       ///
â”‚       /// * `text` - The string slice to pad.
â”‚       /// * `width` - The desired total width of the padded string.
â”‚       ///
â”‚       /// # Returns
â”‚       ///
â”‚       /// A `String` containing the original text padded to the specified width.
â”‚       ///
â”‚       /// # Examples
â”‚       ///
â”‚       /// ```
â”‚       /// use cliux::layout::pad;
â”‚       /// assert_eq!(pad("Hello", 10), "Hello     ");
â”‚       /// assert_eq!(pad("ðŸ‘‹", 5), "ðŸ‘‹   "); // Assuming emoji width 2
â”‚       /// assert_eq!(pad("Rust", 3), "Rust"); // No padding if width is less than or equal to text width
â”‚       /// ```
â”‚       pub fn pad(text: &str, width: usize) -> String {
â”‚           let graphemes = UnicodeSegmentation::graphemes(text, true);
â”‚           let mut display_width = 0;
â”‚       
â”‚           for g in graphemes {
â”‚               let w = g.width();
â”‚               let adjusted = if is_emoji(g) && w == 1 { 2 } else { w };
â”‚               display_width += adjusted;
â”‚           }
â”‚       
â”‚           let padding = width.saturating_sub(display_width);
â”‚           format!("{}{}", text, " ".repeat(padding))
â”‚       }
â”‚       
â”‚       fn is_emoji(g: &str) -> bool {
â”‚           g.chars().any(|c| {
â”‚               let code = c as u32;
â”‚               (code >= 0x1F300 && code <= 0x1FAFF) || (code >= 0x2600 && code <= 0x26FF)
â”‚           })
â”‚       }
â”‚       
â”‚       /// Wraps the given `text` into a vector of strings, ensuring that each line
â”‚       /// does not exceed the specified `width`.
â”‚       ///
â”‚       /// The wrapping is done intelligently, breaking at word boundaries.
â”‚       /// Paragraphs are maintained by processing `text` line by line.
â”‚       ///
â”‚       /// # Arguments
â”‚       ///
â”‚       /// * `text` - The string slice to wrap.
â”‚       /// * `width` - The maximum desired width for each wrapped line.
â”‚       ///
â”‚       /// # Returns
â”‚       ///
â”‚       /// A `Vec<String>` where each element is a wrapped line of the original text.
â”‚       ///
â”‚       /// # Examples
â”‚       ///
â”‚       /// ```
â”‚       /// use cliux::layout::wrap_text;
â”‚       /// let long_text = "This is a very long sentence that needs to be wrapped.";
â”‚       /// let wrapped_lines = wrap_text(long_text, 20);
â”‚       /// assert_eq!(wrapped_lines, vec![
â”‚       ///     "This is a very",
â”‚       ///     "long sentence that",
â”‚       ///     "needs to be wrapped."
â”‚       /// ]);
â”‚       ///
â”‚       /// let paragraph_text = "First paragraph.\nSecond paragraph is a bit longer and needs wrapping.";
â”‚       /// let wrapped_paragraphs = wrap_text(paragraph_text, 25);
â”‚       /// assert_eq!(wrapped_paragraphs, vec![
â”‚       ///     "First paragraph.",
â”‚       ///     "Second paragraph is a",
â”‚       ///     "bit longer and needs",
â”‚       ///     "wrapping."
â”‚       /// ]);
â”‚       /// ```
â”‚       pub fn wrap_text(text: &str, width: usize) -> Vec<String> {
â”‚           let mut lines = Vec::new();
â”‚           for paragraph in text.lines() {
â”‚               let mut current = String::new();
â”‚               for word in paragraph.split_whitespace() {
â”‚                   if current.len() + word.len() + 1 > width {
â”‚                       lines.push(current.trim_end().to_string());
â”‚                       current.clear();
â”‚                   }
â”‚                   current.push_str(word);
â”‚                   current.push(' ');
â”‚               }
â”‚               if !current.is_empty() {
â”‚                   lines.push(current.trim_end().to_string());
â”‚               }
â”‚           }
â”‚           lines
â”‚       }
â”‚       --- FILE CONTENT END ---
â”‚   â””â”€â”€ lib.rs
â”‚       --- FILE CONTENT START ---
â”‚       //! # cliux
â”‚       //!
â”‚       //! `cliux` is a lightweight Rust crate for formatting terminal output with clean, readable components â€” no TUI required.
â”‚       //! It helps CLI tools present information with structure and style using boxes, sections, dividers, and smart padding.
â”‚       
â”‚       pub mod components;
â”‚       pub mod layout;
â”‚       
â”‚       /// Re-exports the `Boxed` struct from the `components` module.
â”‚       pub use components::Boxed;
â”‚       /// Re-exports the `Divider` struct from the `components` module.
â”‚       pub use components::Divider;
â”‚       /// Re-exports the `Label` struct from the `components` module.
â”‚       pub use components::Label;
â”‚       /// Re-exports the `List` struct from the `components` module.
â”‚       pub use components::List;
â”‚       /// Re-exports the `Note` struct from the `components` module.
â”‚       pub use components::Note;
â”‚       /// Re-exports the `Section` struct from the `components` module.
â”‚       pub use components::Section;
â”‚       /// Re-exports the `Table` struct from the `components` module.
â”‚       pub use components::Table;
â”‚       /// Re-exports the `Tag` struct from the `components` module.
â”‚       pub use components::Tag;
â”‚       --- FILE CONTENT END ---
â”œâ”€â”€ .gitignore
    --- FILE CONTENT START ---
    /target
    --- FILE CONTENT END ---
â”œâ”€â”€ Cargo.lock
    --- FILE CONTENT START ---
    # This file is automatically @generated by Cargo.
    # It is not intended for manual editing.
    version = 4
    
    [[package]]
    name = "ansi_term"
    version = "0.12.1"
    source = "registry+https://github.com/rust-lang/crates.io-index"
    checksum = "d52a9bb7ec0cf484c551830a7ce27bd20d67eac647e1befb56b0be4ee39a55d2"
    dependencies = [
     "winapi",
    ]
    
    [[package]]
    name = "cliux"
    version = "0.4.1"
    dependencies = [
     "ansi_term",
     "unicode-segmentation",
     "unicode-width",
    ]
    
    [[package]]
    name = "unicode-segmentation"
    version = "1.12.0"
    source = "registry+https://github.com/rust-lang/crates.io-index"
    checksum = "f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493"
    
    [[package]]
    name = "unicode-width"
    version = "0.1.14"
    source = "registry+https://github.com/rust-lang/crates.io-index"
    checksum = "7dd6e30e90baa6f72411720665d41d89b9a3d039dc45b8faea1ddd07f617f6af"
    
    [[package]]
    name = "winapi"
    version = "0.3.9"
    source = "registry+https://github.com/rust-lang/crates.io-index"
    checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
    dependencies = [
     "winapi-i686-pc-windows-gnu",
     "winapi-x86_64-pc-windows-gnu",
    ]
    
    [[package]]
    name = "winapi-i686-pc-windows-gnu"
    version = "0.4.0"
    source = "registry+https://github.com/rust-lang/crates.io-index"
    checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
    
    [[package]]
    name = "winapi-x86_64-pc-windows-gnu"
    version = "0.4.0"
    source = "registry+https://github.com/rust-lang/crates.io-index"
    checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
    --- FILE CONTENT END ---
â”œâ”€â”€ Cargo.toml
    --- FILE CONTENT START ---
    [package]
    name = "cliux"
    version = "0.4.1"
    edition = "2024"
    license = "MIT"
    authors = ["Pjdur"]
    repository = "https://github.com/Pjdur/cliux"
    description = "Styled terminal output made simple â€” boxes, sections, dividers, and emoji-aware padding for CLI tools."
    keywords = ["cli", "terminal", "output"]
    categories = ["command-line-interface", "text-processing"]
    
    [dependencies]
    ansi_term = "0.12.1"
    unicode-segmentation = "1.10"
    unicode-width = "0.1"
    --- FILE CONTENT END ---
â”œâ”€â”€ CHANGELOG.md
    --- FILE CONTENT START ---
    # Changelog
    
    All notable changes to this project will be documented here.
    
    ## [v0.4.1] â€“ 2025-11-05
    
    ### New Components
    
    - **`Table`**: Render structured rows and columns with optional headers, borders, and custom widths.
      - Supports auto-width calculation, clean ASCII framing, and padded alignment.
      - Example: `Table::new().headers(...).row(...).print();`
    
    - **`Note`**: Display styled callouts for tips, warnings, and info blocks.
      - Supports border styles: `"rounded"`, `"square"`, and `"+"`.
      - Optional emoji icons, color, and width control.
      - Example: `Note::new("Be careful").icon("âš ï¸").style("rounded").print();`
    
    ### Unicode Caveat
    
    - Emoji rendering may vary across terminals. While `cliux` accounts for grapheme width, some emojis (e.g. `âš ï¸`) may appear misaligned due to terminal font behavior.
      - Use monospace-safe symbols (`!`, `*`, `i`) if alignment is critical.
      - This issue is cosmetic only and does not affect functionality.
    
    ### Fixed
    
    - Remove unnecessary `numbered` bool from `List` component.
    
    ## [0.3.0] - 2025-11-04
    
    ### Added
    - `Tag` component for inline status markers with customizable wrappers and colors
    - `List` component for bullet-pointed or numbered lists with optional wrapping
    - Demo GIFs for `Tag` and `List`
    - Examples for `tag.rs` and `list.rs`
    
    ### Improved
    - All examples now use root-level imports (`use cliux::...`)
    - README updated with new components and visuals
    
    ## [0.2.0] - 2025-11-01
    
    ### Added
    - `Label` component with `.style()`, `.color()`, `.bold()`, and `.inline()`
    - `examples/label.rs` and demo GIF
    - README section for `Label`
    
    ### Improved
    - Internal docs and examples
    
    ## [0.1.3] - 2025-10-31
    
    - Added inline documentation for all public methods and properties
    - Improved contributor onboarding with `CONTRIBUTING.md`
    - Updated changelog and published docs to docs.rs
    
    ## [0.1.2] - 2025-10-30
    ### Added
    - `.wrap()` support for `Section`
    - Animated GIF demos for `Boxed`, `Section`, and `Divider`
    
    ### Improved
    - README examples and visuals
    
    ## [0.1.1] - 2025-10-30
    ### Added
    - `.style()` method for `Section` for custom divider characters
    
    ## [0.1.0] - 2025-10-30
    Initial release
    --- FILE CONTENT END ---
â”œâ”€â”€ CONTRIBUTING.md
    --- FILE CONTENT START ---
    # Contributing to cliux
    
    Thanks for your interest in contributing!
    
    ## Getting Started
    
    1. Clone the repo and run examples in `/examples`
    2. Use `cargo test` to run unit tests
    3. Use `cargo doc --open` to preview documentation
    
    ## Suggestions Welcome
    
    Feel free to open issues for:
    - New components (e.g. Label, Table)
    - Styling features (e.g. color support)
    - Layout improvements or edge cases
    
    ## Code Style
    
    - Use idiomatic Rust
    - Document public APIs with `///` comments
    - Keep components focused and composable
    
    Pull requests are welcome!
    --- FILE CONTENT END ---
â”œâ”€â”€ LICENSE
    --- FILE CONTENT START ---
    Copyright 2025 Pjdur
    
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the â€œSoftwareâ€), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED â€œAS ISâ€, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    --- FILE CONTENT END ---
â””â”€â”€ README.md
    --- FILE CONTENT START ---
    # cliux
    
    **Styled terminal output made simple.**
    
    `cliux` is a lightweight Rust crate for formatting terminal output with clean, readable components â€” no TUI required. It helps CLI tools present information with structure and style using boxes, sections, dividers, lists, tags, and smart padding.
    
    ## âœ¨ Features
    
    - `Boxed` â€” bordered containers with titles and content
    - `Section` â€” titled blocks with horizontal dividers
    - `Divider` â€” customizable horizontal lines
    - `List` â€” bullet-pointed lists with customizable styles
    - `Tag` â€” colored tags with customizable styles
    - `Padding` â€” Unicode-aware padding (emoji-safe)
    
    ## Examples
    
    ### Boxed
    
    ```rust
    use cliux::Boxed;
    
    fn main() {
        Boxed::new("Cliux Boxed")
            .content("This code uses the cliux library to create a boxed section.")
            .width(61)
            .print();
    }
    ```
    
    ### Label
    
    ```rust
    use cliux::Label;
    
    fn main() {
        Label::new("INFO").style("info").print();
        Label::new("âœ“ Done").style("success").print();
        Label::new("ERROR").style("error").print();
    }
    ```
    ### Section
    
    ```rust
    use cliux::Section;
    
    fn main() {
        Section::new("Wrapped Section")
            .content("This is a long sentence that will be wrapped intelligently across multiple lines.")
            .width(40)
            .wrap(true)
            .style('â”€')
            .print();
    }
    ```
    
    ### Divider
    
    ```rust
    use cliux::Divider;
    
    fn main() {
        Divider::new(30).style('=').print();
    }
    ```
    
    ### List
    
    ```rust
    use cliux::List;
    
    fn main() {
        List::new(vec!["First item", "Second item", "Third item"])
            .bullet("*")
            .width(40)
            .print();
    
        List::new(vec!["One", "Two", "Three"])
            .numbered()
            .print();
    }
    ```
    
    ### Tag
    
    ```rust
    use cliux::Tag;
    
    fn main() {
        Tag::new("beta").rounded().color("yellow").bold(true).print();
        Tag::new("admin").curly().color("red").print();
        Tag::new("draft").print();
    }
    ```
    
    ### Table
    
    ```rust
    use cliux::Table;
    
    fn main() {
        Table::new()
            .headers(&["Name", "Status"])
            .row(&["cliux", "active"])
            .row(&["other", "pending"])
            .widths(&[20, 10])
            .bordered(true)
            .print();
    }
    ```
    
    ### Note
    
    ```rust
    use cliux::Note;
    
    fn main() {
        Note::new("Be careful with this setting.")
            .kind("warning")
            .style("rounded")
            .width(40)
            .print();
    
        Note::new("Tip: You can use --force here.")
            .kind("info")
            .style("+")
            .width(40)
            .print();
    }
    ```
    
    ## ðŸ“š Usage
    
    Add to your `Cargo.toml`:
    
    ```toml
    cliux = "0.3.0"
    ```
    
    ## Screenshots
    
    ### Boxed
    
    ![Boxed](assets/boxed.gif)
    
    ### Label
    
    ![Label](assets/label.gif)
    
    ### Section
    
    ![Section](assets/section.gif)
    
    ### Divider
    
    ![Divider](assets/divider.gif)
    
    ### List
    
    ![List](assets/list.gif)
    
    ### Tag
    
    ![Tag](assets/tag.gif)
    
    ### Table
    
    ![Table](assets/table.gif)
    
    ### Note
    
    ![Note](assets/note.gif)
    
    ## ðŸš§ Status
    
    This is an early release. Components and layout may evolve. Contributions and feedback welcome!
    --- FILE CONTENT END ---
